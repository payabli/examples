// src/project.ts
import { Project as TsProject, ScriptKind } from "ts-morph";

// src/parser.ts
import { extract, unbox, box } from "@pandacss/extractor";
import { logger } from "@pandacss/logger";
import { astish, memo as memo2 } from "@pandacss/shared";
import { Node } from "ts-morph";
import { match } from "ts-pattern";

// src/import.ts
import { memo } from "@pandacss/shared";
var getModuleSpecifierValue = (node) => {
  try {
    return node.getModuleSpecifierValue();
  } catch {
    return;
  }
};
function getImportDeclarations(file, options) {
  const { match: match2 } = options;
  const result = [];
  file.getImportDeclarations().forEach((node) => {
    const source = getModuleSpecifierValue(node);
    if (!source)
      return;
    const specifiers = node.getNamedImports();
    specifiers.forEach((specifier) => {
      const name = specifier.getNameNode().getText();
      const alias = specifier.getAliasNode()?.getText() || name;
      const importMapValue = match2({ name, alias, mod: source });
      if (!importMapValue)
        return;
      result.push({ name, alias, mod: source, importMapValue });
    });
  });
  return {
    value: result,
    toString() {
      return result.map((item) => item.alias).join(", ");
    },
    find(id) {
      return result.find((o) => o.alias === id);
    },
    createMatch(mod, keys) {
      const mods = result.filter((o) => {
        const isFromMod = o.mod.includes(mod) || o.importMapValue === mod;
        const isOneOfKeys = keys.includes(o.name);
        return isFromMod && isOneOfKeys;
      });
      return memo((id) => !!mods.find((mod2) => mod2.alias === id || mod2.name === id));
    },
    match(id) {
      return !!this.find(id);
    },
    getName(id) {
      return this.find(id)?.name || id;
    },
    getAlias(id) {
      return result.find((o) => o.name === id)?.alias || id;
    }
  };
}

// src/parser-result.ts
var ParserResult = class _ParserResult {
  jsx = /* @__PURE__ */ new Set();
  css = /* @__PURE__ */ new Set();
  cva = /* @__PURE__ */ new Set();
  sva = /* @__PURE__ */ new Set();
  recipe = /* @__PURE__ */ new Map();
  pattern = /* @__PURE__ */ new Map();
  filePath;
  set(name, result) {
    this[name].add({ type: "object", ...result });
  }
  setCva(result) {
    this.cva.add({ type: "cva", ...result });
  }
  setSva(result) {
    this.sva.add({ type: "sva", ...result });
  }
  setJsx(result) {
    this.jsx.add({ type: "jsx", ...result });
  }
  setPattern(name, result) {
    this.pattern.get(name) ?? this.pattern.set(name, /* @__PURE__ */ new Set());
    this.pattern.get(name)?.add({ type: "pattern", name, ...result });
  }
  setRecipe(name, result) {
    this.recipe.get(name) ?? this.recipe.set(name, /* @__PURE__ */ new Set());
    this.recipe.get(name)?.add({ type: "recipe", ...result });
  }
  isEmpty() {
    return this.css.size === 0 && this.cva.size === 0 && this.sva.size === 0 && this.recipe.size === 0 && this.pattern.size === 0 && this.jsx.size === 0;
  }
  setFilePath(filePath) {
    this.filePath = filePath;
    return this;
  }
  toArray() {
    const result = [];
    this.css.forEach((item) => result.push(item));
    this.cva.forEach((item) => result.push(item));
    this.sva.forEach((item) => result.push(item));
    this.jsx.forEach((item) => result.push(item));
    this.recipe.forEach((items) => items.forEach((item) => result.push(item)));
    this.pattern.forEach((items) => items.forEach((item) => result.push(item)));
    return result;
  }
  toJSON() {
    return {
      css: Array.from(this.css),
      cva: Array.from(this.cva),
      sva: Array.from(this.sva),
      jsx: Array.from(this.jsx),
      recipe: Object.fromEntries(Array.from(this.recipe.entries()).map(([key, value]) => [key, Array.from(value)])),
      pattern: Object.fromEntries(Array.from(this.pattern.entries()).map(([key, value]) => [key, Array.from(value)]))
    };
  }
  merge(result) {
    result.css.forEach((item) => this.css.add(item));
    result.cva.forEach((item) => this.cva.add(item));
    result.sva.forEach((item) => this.sva.add(item));
    result.jsx.forEach((item) => this.jsx.add(item));
    result.recipe.forEach((items, name) => {
      this.recipe.get(name) ?? this.recipe.set(name, /* @__PURE__ */ new Set());
      items.forEach((item) => this.recipe.get(name)?.add(item));
    });
    result.pattern.forEach((items, name) => {
      this.pattern.get(name) ?? this.pattern.set(name, /* @__PURE__ */ new Set());
      items.forEach((item) => this.pattern.get(name)?.add(item));
    });
    return this;
  }
  static fromJSON(json) {
    const data = JSON.parse(json);
    const result = new _ParserResult();
    result.css = new Set(data.css);
    result.cva = new Set(data.cva);
    result.sva = new Set(data.sva);
    result.jsx = new Set(data.jsx);
    result.recipe = new Map(Object.entries(data.recipe));
    result.pattern = new Map(Object.entries(data.pattern));
    return result;
  }
};
var createParserResult = () => new ParserResult();

// src/parser.ts
import { resolveTsPathPattern } from "@pandacss/config/ts-path";
var isNodeRecipe = (node) => node.type === "recipe";
var isNodePattern = (node) => node.type === "pattern";
var cvaProps = ["compoundVariants", "defaultVariants", "variants", "base"];
var isCva = (map) => cvaProps.some((prop) => map.has(prop));
function createImportMatcher(mod, values) {
  const regex = values ? new RegExp(`^(${values.join("|")})$`) : /.*/;
  return {
    mod,
    regex,
    match(value) {
      return regex.test(value);
    }
  };
}
var combineResult = (unboxed) => {
  return [...unboxed.conditions, unboxed.raw, ...unboxed.spreadConditions];
};
var fallback = (box2) => ({
  value: void 0,
  getNode: () => box2.getNode(),
  getStack: () => box2.getStack()
});
var defaultEnv = { preset: "ECMA" };
var identityFn = (styles) => styles;
var evaluateOptions = { environment: defaultEnv };
function createParser(options) {
  const { jsx, getRecipesByJsxName, getPatternsByJsxName, tsOptions, join } = options;
  const importMap = Object.fromEntries(Object.entries(options.importMap).map(([key, value]) => [key, join(...value)]));
  const importRegex = [
    createImportMatcher(importMap.css, ["css", "cva", "sva"]),
    createImportMatcher(importMap.recipe),
    createImportMatcher(importMap.pattern)
  ];
  if (jsx.framework) {
    importRegex.push(createImportMatcher(importMap.jsx, [jsx.factory, ...jsx.nodes.map((node) => node.jsxName)]));
  }
  return function parse2(sourceFile) {
    if (!sourceFile)
      return;
    const filePath = sourceFile.getFilePath();
    const imports = getImportDeclarations(sourceFile, {
      match(value) {
        let found = false;
        for (const { regex, mod } of importRegex) {
          if (!regex.test(value.name))
            continue;
          if (value.mod.includes(mod)) {
            found = true;
            break;
          }
          if (tsOptions?.pathMappings) {
            const filename = resolveTsPathPattern(tsOptions.pathMappings, value.mod);
            if (filename?.includes(mod)) {
              found = mod;
              break;
            }
          }
        }
        return found;
      }
    });
    const collector = createParserResult();
    logger.debug(
      "ast:import",
      imports.value.length ? `Found import { ${imports} } in ${filePath}` : `No import found in ${filePath}`
    );
    const [css] = importRegex;
    const jsxFactoryAlias = jsx ? imports.getAlias(jsx.factory) : "styled";
    const isValidPattern = imports.createMatch(importMap.pattern, options.patternKeys);
    const isValidRecipe = imports.createMatch(importMap.recipe, options.recipeKeys);
    const isValidStyleFn = (name) => name === jsx?.factory;
    const isFactory = (name) => Boolean(jsx && name.startsWith(jsxFactoryAlias));
    const isRawFn = (fullName) => {
      const name = fullName.split(".raw")[0] ?? "";
      return name === "css" || isValidPattern(name) || isValidRecipe(name);
    };
    const patternPropertiesByName = /* @__PURE__ */ new Map();
    const patternJsxLists = (jsx?.nodes ?? []).filter(isNodePattern).reduce(
      (acc, pattern) => {
        patternPropertiesByName.set(pattern.jsxName, new Set(pattern.props ?? []));
        pattern.jsx?.forEach((jsx2) => {
          if (typeof jsx2 === "string") {
            acc.string.add(jsx2);
          } else if (jsx2) {
            acc.regex.push(jsx2);
          }
        });
        return acc;
      },
      { string: /* @__PURE__ */ new Set(), regex: [] }
    );
    const recipes = /* @__PURE__ */ new Set();
    const patterns = /* @__PURE__ */ new Set();
    imports.value.forEach((importDeclaration) => {
      const { alias } = importDeclaration;
      if (isValidRecipe(alias)) {
        recipes.add(alias);
      }
      if (isValidPattern(alias)) {
        patterns.add(alias);
      }
    });
    const functions = /* @__PURE__ */ new Map();
    const components = /* @__PURE__ */ new Map();
    const propertiesMap = /* @__PURE__ */ new Map();
    const recipePropertiesByJsxName = /* @__PURE__ */ new Map();
    const recipeJsxLists = (jsx?.nodes ?? []).filter(isNodeRecipe).reduce(
      (acc, recipe) => {
        recipePropertiesByJsxName.set(recipe.jsxName, new Set(recipe.props ?? []));
        recipe.jsx?.forEach((jsx2) => {
          if (typeof jsx2 === "string") {
            acc.string.add(jsx2);
          } else {
            acc.regex.push(jsx2);
          }
        });
        return acc;
      },
      { string: /* @__PURE__ */ new Set(), regex: [] }
    );
    const cvaAlias = imports.getAlias("cva");
    const cssAlias = imports.getAlias("css");
    const svaAlias = imports.getAlias("sva");
    if (options.jsx) {
      options.jsx.nodes.forEach((node) => {
        const alias = imports.getAlias(node.jsxName);
        node.props?.forEach((prop) => propertiesMap.set(prop, true));
        functions.set(node.baseName, propertiesMap);
        functions.set(alias, propertiesMap);
        components.set(alias, propertiesMap);
      });
    }
    const isJsxTagRecipe = memo2(
      (tagName) => recipeJsxLists.string.has(tagName) || recipeJsxLists.regex.some((regex) => regex.test(tagName))
    );
    const isJsxTagPattern = memo2(
      (tagName) => patternJsxLists.string.has(tagName) || patternJsxLists.regex.some((regex) => regex.test(tagName))
    );
    const matchTag = memo2((tagName) => {
      if (!tagName)
        return false;
      return components.has(tagName) || isUpperCase(tagName) || isFactory(tagName) || isJsxTagRecipe(tagName) || isJsxTagPattern(tagName);
    });
    const isRecipeOrPatternProp = memo2((tagName, propName) => {
      if (isJsxTagRecipe(tagName)) {
        const recipeList = getRecipesByJsxName(tagName);
        return recipeList.some((recipe) => recipePropertiesByJsxName.get(recipe.jsxName)?.has(propName));
      }
      if (isJsxTagPattern(tagName)) {
        const patternList = getPatternsByJsxName(tagName);
        return patternList.some((pattern) => patternPropertiesByName.get(pattern.baseName)?.has(propName));
      }
      return false;
    });
    const matchTagProp = match(jsx?.styleProps).with(
      "all",
      () => memo2((tagName, propName) => {
        return Boolean(components.get(tagName)?.has(propName)) || options.jsx?.isStyleProp(propName) || propertiesMap.has(propName) || isRecipeOrPatternProp(tagName, propName);
      })
    ).with("minimal", () => (tagName, propName) => {
      return propName === "css" || isRecipeOrPatternProp(tagName, propName);
    }).otherwise(() => (tagName, propName) => isRecipeOrPatternProp(tagName, propName));
    const matchFn = memo2((fnName) => {
      if (recipes.has(fnName) || patterns.has(fnName))
        return true;
      if (fnName === cvaAlias || fnName === cssAlias || fnName === svaAlias || isRawFn(fnName) || isFactory(fnName))
        return true;
      return functions.has(fnName);
    });
    const measure = logger.time.debug(`Tokens extracted from ${filePath}`);
    const extractResultByName = extract({
      ast: sourceFile,
      components: {
        matchTag: (prop) => matchTag(prop.tagName),
        matchProp: (prop) => matchTagProp(prop.tagName, prop.propName)
      },
      functions: {
        matchFn: (prop) => matchFn(prop.fnName),
        matchProp: () => true,
        matchArg: (prop) => {
          if (prop.fnName === jsxFactoryAlias && prop.index === 1 && Node.isIdentifier(prop.argNode))
            return false;
          return true;
        }
      },
      taggedTemplates: {
        matchTaggedTemplate: (tag) => matchFn(tag.fnName)
      },
      getEvaluateOptions: (node) => {
        if (!Node.isCallExpression(node))
          return evaluateOptions;
        const propAccessExpr = node.getExpression();
        if (!Node.isPropertyAccessExpression(propAccessExpr))
          return evaluateOptions;
        let name = propAccessExpr.getText();
        if (!isRawFn(name)) {
          return evaluateOptions;
        }
        name = name.replace(".raw", "");
        return {
          environment: Object.assign({}, defaultEnv, { extra: { [name]: { raw: identityFn } } })
        };
      },
      flags: { skipTraverseFiles: true }
    });
    measure();
    extractResultByName.forEach((result, alias) => {
      let name = imports.getName(alias);
      if (isRawFn(name))
        name = name.replace(".raw", "");
      logger.debug(`ast:${name}`, name !== alias ? { kind: result.kind, alias } : { kind: result.kind });
      if (result.kind === "function") {
        match(name).when(css.match, (name2) => {
          result.queryList.forEach((query) => {
            if (query.kind === "call-expression") {
              if (query.box.value.length > 1) {
                collector.set(name2, {
                  name: name2,
                  box: query.box,
                  data: query.box.value.reduce(
                    (acc, value) => [...acc, ...combineResult(unbox(value))],
                    []
                  )
                });
              } else {
                collector.set(name2, {
                  name: name2,
                  box: query.box.value[0] ?? fallback(query.box),
                  data: combineResult(unbox(query.box.value[0]))
                });
              }
            } else if (query.kind === "tagged-template") {
              const obj = astish(query.box.value);
              collector.set(name2, {
                name: name2,
                box: query.box ?? fallback(query.box),
                data: [obj]
              });
            }
          });
        }).when(isValidPattern, (name2) => {
          result.queryList.forEach((query) => {
            if (query.kind === "call-expression") {
              collector.setPattern(name2, {
                name: name2,
                box: query.box.value[0] ?? fallback(query.box),
                data: combineResult(unbox(query.box.value[0]))
              });
            }
          });
        }).when(isValidRecipe, (name2) => {
          result.queryList.forEach((query) => {
            if (query.kind === "call-expression") {
              collector.setRecipe(name2, {
                name: name2,
                box: query.box.value[0] ?? fallback(query.box),
                data: combineResult(unbox(query.box.value[0]))
              });
            }
          });
        }).when(isValidStyleFn, () => {
          result.queryList.forEach((query) => {
            if (query.kind === "call-expression" && query.box.value[1]) {
              const map = query.box.value[1];
              const boxNode = box.isMap(map) ? map : fallback(query.box);
              const result2 = { name, box: boxNode, data: combineResult(unbox(boxNode)) };
              if (box.isMap(map) && isCva(map.value)) {
                collector.setCva(result2);
              } else {
                collector.set("css", result2);
              }
              const options2 = query.box.value[2];
              if (box.isUnresolvable(map) && options2 && box.isMap(options2) && options2.value.has("defaultProps")) {
                const maybeIdentifier = map.getNode();
                if (Node.isIdentifier(maybeIdentifier)) {
                  const name2 = maybeIdentifier.getText();
                  const recipeName = imports.getName(name2);
                  collector.setRecipe(recipeName, {
                    type: "jsx-recipe",
                    name: recipeName,
                    box: options2,
                    data: combineResult(unbox(options2.value.get("defaultProps")))
                  });
                }
              }
            } else if (query.kind === "tagged-template") {
              const obj = astish(query.box.value);
              collector.set("css", {
                name,
                box: query.box ?? fallback(query.box),
                data: [obj]
              });
            }
          });
        }).when(isFactory, (name2) => {
          result.queryList.forEach((query) => {
            if (query.kind === "call-expression") {
              const map = query.box.value[0];
              const boxNode = box.isMap(map) ? map : fallback(query.box);
              const result2 = { name: name2, box: boxNode, data: combineResult(unbox(boxNode)) };
              if (box.isMap(map) && isCva(map.value)) {
                collector.setCva(result2);
              } else {
                collector.set("css", result2);
              }
            } else if (query.kind === "tagged-template") {
              const obj = astish(query.box.value);
              collector.set("css", {
                name: name2,
                box: query.box ?? fallback(query.box),
                data: [obj]
              });
            }
          });
        }).otherwise(() => {
        });
      } else if (result.kind === "component") {
        result.queryList.forEach((query) => {
          const data = combineResult(unbox(query.box));
          match(name).when(isFactory, (jsxName) => {
            collector.setJsx({ name: jsxName, box: query.box, type: "jsx-factory", data });
          }).when(isJsxTagPattern, (jsxName) => {
            collector.setPattern(jsxName, { type: "jsx-pattern", name: jsxName, box: query.box, data });
          }).when(isJsxTagRecipe, (jsxName) => {
            const recipeList = getRecipesByJsxName(jsxName);
            recipeList.map((recipe) => {
              collector.setRecipe(recipe.baseName, { type: "jsx-recipe", name: jsxName, box: query.box, data });
            });
          }).otherwise(() => {
            collector.setJsx({ name, box: query.box, type: "jsx", data });
          });
        });
      }
    });
    return collector;
  };
}
var isUpperCase = (value) => value[0] === value[0]?.toUpperCase();

// src/vue-to-tsx.ts
import { parse } from "@vue/compiler-sfc";
import MagicString from "magic-string";
var NodeTypes = {
  ROOT: 0,
  ELEMENT: 1,
  TEXT: 2,
  COMMENT: 3,
  SIMPLE_EXPRESSION: 4,
  INTERPOLATION: 5,
  ATTRIBUTE: 6,
  DIRECTIVE: 7,
  COMPOUND_EXPRESSION: 8,
  IF: 9,
  IF_BRANCH: 10,
  FOR: 11,
  TEXT_CALL: 12,
  VNODE_CALL: 13,
  JS_CALL_EXPRESSION: 14,
  JS_OBJECT_EXPRESSION: 15,
  JS_PROPERTY: 16,
  JS_ARRAY_EXPRESSION: 17,
  JS_FUNCTION_EXPRESSION: 18,
  JS_CONDITIONAL_EXPRESSION: 19,
  JS_CACHE_EXPRESSION: 20,
  JS_BLOCK_STATEMENT: 21,
  JS_TEMPLATE_LITERAL: 22,
  JS_IF_STATEMENT: 23,
  JS_ASSIGNMENT_EXPRESSION: 24,
  JS_SEQUENCE_EXPRESSION: 25,
  JS_RETURN_STATEMENT: 26
};
var vueToTsx = (code) => {
  try {
    const parsed = parse(code);
    const fileStr = new MagicString(`<template>${parsed.descriptor.template?.content}</template>` ?? "");
    const rewriteProp = (prop) => {
      if (prop.type === NodeTypes.DIRECTIVE && prop.exp?.type === NodeTypes.SIMPLE_EXPRESSION && prop.arg?.type === NodeTypes.SIMPLE_EXPRESSION) {
        fileStr.replace(prop.loc.source, `${prop.arg.content}={${prop.exp.content}}`);
      }
    };
    const stack = [...parsed.descriptor.template.ast.children];
    while (stack.length) {
      const node = stack.pop();
      if (!node)
        continue;
      if (node.type === NodeTypes.ELEMENT) {
        node.props.forEach(rewriteProp);
        node.children.forEach((child) => stack.push(child));
      }
    }
    const scriptContent = (parsed.descriptor.scriptSetup ?? parsed.descriptor.script)?.content + "\n";
    const transformed = new MagicString(`${scriptContent}
const render = ${fileStr.toString()}`);
    return transformed.toString();
  } catch (err) {
    return "";
  }
};

// src/svelte-to-tsx.ts
import MagicString2 from "magic-string";
var regex_style_tags = /<!--[^]*?-->|<style(\s[^]*?)?(?:>([^]*?)<\/style>|\/>)/gi;
var regex_script_tags = /<!--[^]*?-->|<script(\s[^]*?)?(?:>([^]*?)<\/script>|\/>)/gi;
var svelteToTsx = (code) => {
  try {
    const scripts = [];
    const original = new MagicString2(code);
    let match2;
    while ((match2 = regex_script_tags.exec(code)) != null) {
      const [fullMatch, _attributesStr, scriptContent] = match2;
      if (scriptContent) {
        scripts.push(scriptContent);
        original.remove(match2.index, match2.index + fullMatch.length);
      }
    }
    const templateContent = original.toString().trimStart().replace(regex_style_tags, "").replace(regex_style_tags, "");
    const transformed = `${scripts.join("")}
const render = <div>${templateContent}</div>`;
    return transformed.toString().trim();
  } catch (err) {
    return "";
  }
};

// src/project.ts
var createTsProject = (options) => new TsProject({
  skipAddingFilesFromTsConfig: true,
  skipFileDependencyResolution: true,
  skipLoadingLibFiles: true,
  ...options,
  compilerOptions: {
    allowJs: true,
    strictNullChecks: false,
    skipLibCheck: true,
    ...options.compilerOptions
  }
});
var createProject = ({
  getFiles,
  readFile,
  parserOptions,
  hooks,
  ...projectOptions
}) => {
  const project = createTsProject(projectOptions);
  const parser = createParser(parserOptions);
  const getSourceFile = (filePath) => project.getSourceFile(filePath);
  const removeSourceFile = (filePath) => {
    const sourceFile = project.getSourceFile(filePath);
    if (sourceFile)
      project.removeSourceFile(sourceFile);
  };
  const createSourceFile = (filePath) => project.createSourceFile(filePath, readFile(filePath), {
    overwrite: true,
    scriptKind: ScriptKind.TSX
  });
  const addSourceFile = (filePath, content) => project.createSourceFile(filePath, content, {
    overwrite: true,
    scriptKind: ScriptKind.TSX
  });
  const parseSourceFile = (filePath) => {
    if (filePath.endsWith(".json")) {
      const content2 = readFile(filePath);
      hooks.callHook("parser:before", filePath, content2);
      const result2 = ParserResult.fromJSON(content2).setFilePath(filePath);
      hooks.callHook("parser:after", filePath, result2);
      return result2;
    }
    const sourceFile = project.getSourceFile(filePath);
    if (!sourceFile)
      return;
    const content = sourceFile.getText();
    const transformed = transformFile(filePath, content);
    if (content !== transformed) {
      sourceFile.replaceWithText(transformed);
    }
    hooks.callHook("parser:before", filePath, content);
    const result = parser(sourceFile)?.setFilePath(filePath);
    hooks.callHook("parser:after", filePath, result);
    return result;
  };
  const files = getFiles();
  for (const file of files) {
    createSourceFile(file);
  }
  const reloadSourceFile = (filePath) => getSourceFile(filePath)?.refreshFromFileSystemSync();
  const reloadSourceFiles = () => {
    const files2 = getFiles();
    for (const file of files2) {
      const source = getSourceFile(file);
      source?.refreshFromFileSystemSync() ?? project.addSourceFileAtPath(file);
    }
  };
  return {
    getSourceFile,
    removeSourceFile,
    createSourceFile,
    addSourceFile,
    parseSourceFile,
    reloadSourceFile,
    reloadSourceFiles,
    files,
    getFiles,
    readFile
  };
};
var transformFile = (filePath, content) => {
  if (filePath.endsWith(".vue")) {
    return vueToTsx(content);
  }
  if (filePath.endsWith(".svelte")) {
    return svelteToTsx(content);
  }
  return content;
};
export {
  ParserResult,
  createParserResult,
  createProject
};
