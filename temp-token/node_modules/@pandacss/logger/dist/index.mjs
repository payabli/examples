// src/index.ts
import colors4 from "kleur";

// src/create-logger.ts
import colors3 from "kleur";
import { match as match2, Obj as Obj2, pipe as pipe2, when as when2 } from "lil-fp";

// ../../node_modules/.pnpm/escape-string-regexp@5.0.0/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// ../../node_modules/.pnpm/matcher@5.0.0/node_modules/matcher/index.js
var regexpCache = /* @__PURE__ */ new Map();
var sanitizeArray = (input, inputName) => {
  if (!Array.isArray(input)) {
    switch (typeof input) {
      case "string":
        input = [input];
        break;
      case "undefined":
        input = [];
        break;
      default:
        throw new TypeError(`Expected '${inputName}' to be a string or an array, but got a type of '${typeof input}'`);
    }
  }
  return input.filter((string) => {
    if (typeof string !== "string") {
      if (typeof string === "undefined") {
        return false;
      }
      throw new TypeError(`Expected '${inputName}' to be an array of strings, but found a type of '${typeof string}' in the array`);
    }
    return true;
  });
};
var makeRegexp = (pattern, options) => {
  options = {
    caseSensitive: false,
    ...options
  };
  const cacheKey = pattern + JSON.stringify(options);
  if (regexpCache.has(cacheKey)) {
    return regexpCache.get(cacheKey);
  }
  const negated = pattern[0] === "!";
  if (negated) {
    pattern = pattern.slice(1);
  }
  pattern = escapeStringRegexp(pattern).replace(/\\\*/g, "[\\s\\S]*");
  const regexp = new RegExp(`^${pattern}$`, options.caseSensitive ? "" : "i");
  regexp.negated = negated;
  regexpCache.set(cacheKey, regexp);
  return regexp;
};
var baseMatcher = (inputs, patterns, options, firstMatchOnly) => {
  inputs = sanitizeArray(inputs, "inputs");
  patterns = sanitizeArray(patterns, "patterns");
  if (patterns.length === 0) {
    return [];
  }
  patterns = patterns.map((pattern) => makeRegexp(pattern, options));
  const { allPatterns } = options || {};
  const result = [];
  for (const input of inputs) {
    let matches2;
    const didFit = [...patterns].fill(false);
    for (const [index, pattern] of patterns.entries()) {
      if (pattern.test(input)) {
        didFit[index] = true;
        matches2 = !pattern.negated;
        if (!matches2) {
          break;
        }
      }
    }
    if (!(matches2 === false || matches2 === void 0 && patterns.some((pattern) => !pattern.negated) || allPatterns && didFit.some((yes, index) => !yes && !patterns[index].negated))) {
      result.push(input);
      if (firstMatchOnly) {
        break;
      }
    }
  }
  return result;
};
function isMatch(inputs, patterns, options) {
  return baseMatcher(inputs, patterns, options, true).length > 0;
}

// src/format-entry.ts
import colors2 from "kleur";
import { match, Obj, otherwise, pipe, when } from "lil-fp";

// src/levels.ts
import colors from "kleur";
var logLevels = {
  debug: { weight: 0, color: colors.magenta },
  info: { weight: 1, color: colors.blue },
  warn: { weight: 2, color: colors.yellow },
  error: { weight: 3, color: colors.red },
  silent: { weight: 4, color: colors.white }
};

// src/format-entry.ts
var formatEntry = (entry) => pipe(
  { entry },
  Obj.assign(({ entry: entry2 }) => ({
    uword: entry2.type ? colors2.gray(`[${entry2.type}]`) : ""
  })),
  match(
    when(
      ({ entry: entry2 }) => entry2.level != null,
      ({ entry: entry2, uword }) => {
        const { msg, level } = entry2;
        const color = logLevels[level].color;
        const label = colors2.bold(color(`${level}`));
        return { label: [`\u{1F43C}`, label, uword].filter(Boolean).join(" "), msg };
      }
    ),
    otherwise(({ entry: entry2, uword }) => {
      const { msg } = entry2;
      return { label: uword ?? "", msg };
    })
  )
);
var createEntry = (level, type, data) => {
  const msg = data instanceof Error ? colors2.red(data.message) : data;
  return { type, level, msg };
};

// src/create-logger.ts
var matches = (filters, value) => filters.some((search) => isMatch(value, search));
var createLogger = (conf = {}) => {
  let level = conf.level ?? "info";
  const { stdout, timing } = pipe2(
    conf,
    ({ filter }) => ({
      getLevel: () => filter ? "debug" : level,
      filter: filter !== "*" ? filter?.split(/[\s,]+/) ?? [] : []
    }),
    Obj2.assignTo("config"),
    Obj2.assign(({ config }) => ({
      isValid(level2, type) {
        const badLevel = logLevels[config.getLevel()].weight > logLevels[level2].weight;
        const badType = config.filter.length > 0 && !matches(config.filter, type);
        return !(badType || badLevel);
      }
    })),
    Obj2.assign(({ isValid, config }) => ({
      stdout(level2) {
        return (type, data) => {
          pipe2(
            createEntry(level2, type, data),
            match2(
              when2(
                ({ level: level3, type: type2 }) => level3 != null && isValid(level3, type2),
                (entry) => {
                  const { msg, label } = formatEntry(entry) ?? {};
                  console.log(label, msg);
                }
              ),
              when2(
                ({ level: level3 }) => config.getLevel() !== "silent" && level3 == null,
                () => {
                  console.log(...[type, data].filter(Boolean));
                }
              )
            )
          );
        };
      }
    })),
    Obj2.assign(({ stdout: stdout2 }) => ({
      timing: (level2) => (msg) => {
        const start = performance.now();
        return () => {
          const end = performance.now();
          const ms = end - start;
          stdout2(level2)("hrtime", `${msg} ${colors3.gray(`(${ms.toFixed(2)}ms)`)}`);
        };
      }
    }))
  );
  return {
    get level() {
      return level;
    },
    set level(newLevel) {
      level = newLevel;
    },
    print(data) {
      console.dir(data, { depth: null, colors: true });
    },
    warn: stdout("warn"),
    info: stdout("info"),
    debug: stdout("debug"),
    error: stdout("error"),
    log: (data) => stdout(null)("", data),
    time: {
      info: timing("info"),
      debug: timing("debug")
    },
    isDebug: Boolean(conf.isDebug)
  };
};

// src/scope.ts
var createLogScope = (scope) => {
  const fn = (subScope) => `${scope}/${subScope}`;
  fn.toString = () => scope;
  return fn;
};

// src/index.ts
var quote = (...str) => colors4.cyan(`\`${str.join("")}\``);
var debug = process.env.PANDA_DEBUG;
var logger = createLogger({
  filter: typeof process !== "undefined" ? debug : void 0,
  isDebug: Boolean(debug)
});
export {
  colors4 as colors,
  createLogScope,
  logger,
  quote
};
