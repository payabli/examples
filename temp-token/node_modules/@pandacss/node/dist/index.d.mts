import * as _pandacss_types from '@pandacss/types';
import { LoadConfigResult, ArtifactId, Runtime, PandaHookable, Artifact, ConfigResultWithHooks, ParserResultType, Config } from '@pandacss/types';
import { Generator } from '@pandacss/generator';
import { PandaProject, ParserResult } from '@pandacss/parser';
import { Difference } from 'microdiff';
import { Root, Message } from 'postcss';

interface DiffConfigResult {
    hasConfigChanged: boolean;
    artifacts: Set<ArtifactId>;
    diffs: Difference[];
}
declare class DiffEngine {
    private ctx;
    private previousConfig;
    constructor(ctx: Generator);
    /**
     * Reload config from disk and refresh the context
     */
    reloadConfigAndRefreshContext(fn?: (conf: LoadConfigResult) => void): Promise<DiffConfigResult>;
    /**
     * Update the context from the refreshed config
     * then persist the changes on each affected engines
     * Returns the list of affected artifacts/engines
     */
    refresh(conf: LoadConfigResult, fn?: (conf: LoadConfigResult) => void): DiffConfigResult;
}

declare class PandaOutputEngine {
    private paths;
    private fs;
    private path;
    constructor({ paths, runtime: { path, fs } }: Generator & {
        runtime: Runtime;
        hooks: PandaHookable;
    });
    empty(): void;
    write(output: Artifact | undefined): Promise<PromiseSettledResult<void>[] | undefined>;
}

declare class PandaContext extends Generator {
    runtime: Runtime;
    project: PandaProject;
    getFiles: () => string[];
    output: PandaOutputEngine;
    diff: DiffEngine;
    constructor(conf: ConfigResultWithHooks);
    appendFilesCss(): string[];
    appendAllCss(): void;
    writeCss(): Promise<PromiseSettledResult<void>[] | undefined>;
}

interface Options {
    onResult?: (file: string, result: ParserResultType) => void;
}
declare function analyzeTokens(ctx: PandaContext, options?: Options): {
    duration: {
        extractTimeByFiles: {
            [k: string]: number;
        };
        extractTotal: number;
        classify: number;
    };
    fileSizes: {
        lineCount: number;
        normal: string | number | any[] | {
            value: any;
            symbol: any;
            exponent: number;
            unit: string;
        };
        minified: string | number | any[] | {
            value: any;
            symbol: any;
            exponent: number;
            unit: string;
        };
        gzip: {
            normal: string | number | any[] | {
                value: any;
                symbol: any;
                exponent: number;
                unit: string;
            };
            minified: string | number | any[] | {
                value: any;
                symbol: any;
                exponent: number;
                unit: string;
            };
        };
    };
} & {
    counts: {
        filesWithTokens: number;
        propNameUsed: number;
        tokenUsed: number;
        shorthandUsed: number;
        propertyPathUsed: number;
        typeUsed: number;
        instanceNameUsed: number;
        kindUsed: number;
        instanceOfKindUsed: number;
        colorsUsed: number;
    };
    stats: {
        filesWithMostInstance: {
            [k: string]: number;
        };
        filesWithMostPropValueCombinations: {
            [k: string]: number;
        };
        mostUseds: {
            propNames: {
                key: string;
                count: number;
            }[];
            tokens: {
                key: string;
                count: number;
            }[];
            shorthands: {
                key: string;
                count: number;
            }[];
            conditions: {
                key: string;
                count: number;
            }[];
            propertyPaths: {
                key: string;
                count: number;
            }[];
            categories: {
                key: string;
                count: number;
            }[];
            types: {
                key: string;
                count: number;
            }[];
            instanceNames: {
                key: string;
                count: number;
            }[];
            fromKinds: {
                key: string;
                count: number;
            }[];
            instanceOfKinds: {
                key: string;
                count: number;
            }[];
            colors: {
                key: string;
                count: number;
            }[];
        };
    };
    details: {
        byId: Map<number, _pandacss_types.ReportItem>;
        byInstanceId: Map<number, _pandacss_types.ReportInstanceItem>;
        byFilepath: Map<string, Set<number>>;
        byInstanceInFilepath: Map<string, Set<number>>;
        globalMaps: {
            byInstanceOfKind: Map<"function" | "component", Set<number>>;
            byPropertyName: Map<string, Set<number>>;
            byCategory: Map<string, Set<number>>;
            byConditionName: Map<string, Set<number>>;
            byShorthand: Map<string, Set<number>>;
            byTokenName: Map<string, Set<number>>;
            byPropertyPath: Map<string, Set<number>>;
            fromKind: Map<"function" | "component", Set<number>>;
            byType: Map<string, Set<number>>;
            byInstanceName: Map<string, Set<number>>;
            colorsUsed: Map<string, Set<number>>;
        };
        byFilePathMaps: Map<string, {
            byInstanceOfKind: Map<"function" | "component", Set<number>>;
            byPropertyName: Map<string, Set<number>>;
            byCategory: Map<string, Set<number>>;
            byConditionName: Map<string, Set<number>>;
            byShorthand: Map<string, Set<number>>;
            byTokenName: Map<string, Set<number>>;
            byPropertyPath: Map<string, Set<number>>;
            fromKind: Map<"function" | "component", Set<number>>;
            byType: Map<string, Set<number>>;
            byInstanceName: Map<string, Set<number>>;
            colorsUsed: Map<string, Set<number>>;
        }>;
    };
};
declare const writeAnalyzeJSON: (filePath: string, result: ReturnType<typeof analyzeTokens>, ctx: PandaContext) => Promise<void>;

declare class Builder {
    /**
     * The current panda context
     */
    context: PandaContext | undefined;
    private hasEmitted;
    private affecteds;
    getConfigPath: () => string;
    setup: (options?: {
        configPath?: string;
        cwd?: string;
    }) => Promise<PandaContext | undefined>;
    emit(): Promise<void>;
    setupContext: (options: {
        configPath: string;
        cwd?: string;
    }) => Promise<PandaContext>;
    getContextOrThrow: () => PandaContext;
    getFileMeta: (file: string) => {
        mtime: number;
        isUnchanged: boolean;
    };
    extractFile: (ctx: PandaContext, file: string) => Promise<ParserResult | undefined>;
    checkFilesChanged(files: string[]): boolean;
    extract: () => Promise<void>;
    toString: () => string;
    isValidRoot: (root: Root) => boolean;
    private initialRoot;
    write: (root: Root) => void;
    registerDependency: (fn: (dep: Message) => void) => void;
}

declare function findConfig(): string | undefined;
declare function loadConfigAndCreateContext(options?: {
    cwd?: string;
    config?: Config;
    configPath?: string;
}): Promise<PandaContext>;

declare function debugFiles(ctx: PandaContext, options: {
    outdir: string;
    dry: boolean;
    onlyConfig?: boolean;
}): Promise<void>;

declare function emitArtifacts(ctx: PandaContext, ids?: ArtifactId[]): Promise<{
    box: string;
    msg: string;
}>;

declare function execCommand(cmd: string, cwd: string): Promise<void>;

/**
 * Parse a file and return the corresponding css
 */
declare function extractFile(ctx: PandaContext, filePath: string): ParserResult | undefined;
type CssArtifactType = 'preflight' | 'tokens' | 'static' | 'global' | 'keyframes';

declare function generate(config: Config, configPath?: string): Promise<void>;

declare function setupGitIgnore(ctx: PandaContext): void;

declare function parseDependency(fileOrGlob: string): Message | null;

type SetupOptions = Partial<Config> & {
    force?: boolean;
};
declare function setupConfig(cwd: string, opts?: SetupOptions): Promise<void>;
declare function setupPostcss(cwd: string): Promise<void>;

declare function shipFiles(ctx: PandaContext, outfile: string): Promise<void>;

export { Builder, CssArtifactType, PandaContext, analyzeTokens, debugFiles, emitArtifacts, execCommand, extractFile, findConfig, generate, loadConfigAndCreateContext, parseDependency, setupConfig, setupGitIgnore, setupPostcss, shipFiles, writeAnalyzeJSON };
