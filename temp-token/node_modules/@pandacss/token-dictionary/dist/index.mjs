// src/create-dictionary.ts
import { getDotPath as getDotPath2, mapToJson as mapToJson2 } from "@pandacss/shared";

// src/dictionary.ts
import { compact, isString, mapObject, memo, walkObject as walkObject2 } from "@pandacss/shared";
import { isMatching as isMatching2, match } from "ts-pattern";

// src/is-composite.ts
import { P, isMatching } from "ts-pattern";
var isCompositeShadow = isMatching({
  inset: P.optional(P.boolean),
  offsetX: P.number,
  offsetY: P.number,
  blur: P.number,
  spread: P.number,
  color: P.string
});
var isCompositeGradient = isMatching({
  type: P.string,
  placement: P.string,
  stops: P.union(
    P.array(P.string),
    P.array({
      color: P.string,
      position: P.number
    })
  )
});
var isCompositeBorder = isMatching({
  color: P.string,
  width: P.union(P.string, P.number),
  style: P.string
});
var isCompositeAsset = isMatching({
  type: P.union("url", "svg"),
  value: P.string
});
var isCompositeTokenValue = (value) => {
  return isCompositeGradient(value) || isCompositeShadow(value) || isCompositeBorder(value) || isCompositeAsset(value) || Array.isArray(value);
};

// src/token.ts
import { isBaseCondition, toHash, walkObject } from "@pandacss/shared";

// src/utils.ts
import { isObject } from "@pandacss/shared";
var REFERENCE_REGEX = /(\$[^\s,]+\w)|({([^}]*)})/g;
var curlyBracketRegex = /[{}]/g;
function getReferences(value) {
  if (typeof value !== "string")
    return [];
  const matches = value.match(REFERENCE_REGEX);
  if (!matches)
    return [];
  return matches.map((match3) => match3.replace(curlyBracketRegex, "")).map((value2) => value2.trim());
}
function hasReference(value) {
  return REFERENCE_REGEX.test(value);
}
function mapToJson(map) {
  const obj = {};
  map.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}
var isToken = (value) => {
  return isObject(value) && "value" in value;
};
function assertTokenFormat(token) {
  if (!isToken(token)) {
    throw new Error(`Invalid token format: ${JSON.stringify(token)}`);
  }
}

// src/token.ts
var Token = class _Token {
  name;
  value;
  originalValue;
  path;
  type;
  description;
  extensions;
  constructor(data) {
    this.name = data.name;
    this.value = data.value;
    this.originalValue = data.value;
    this.path = data.path ?? [];
    if (data.type) {
      this.type = data.type;
    }
    if (data.description) {
      this.description = data.description;
    }
    this.extensions = data.extensions ?? {};
    this.extensions.condition = data.extensions?.condition ?? "base";
    this.setType();
  }
  /**
   * The unique identifier of the token.
   */
  get id() {
    return toHash(`${this.name}-${this.extensions.condition}-${this.value}`);
  }
  /**
   * Whether the token is a conditional token.
   * Conditional tokens are tokens that have multiple values based on a condition.
   */
  get isConditional() {
    return !!this.extensions?.conditions;
  }
  /**
   * Whether the token has a reference in its value.
   * e.g. {color.gray.100}
   */
  get hasReference() {
    return !!this.extensions?.references;
  }
  /**
   * Whether the token is a complex or composite token.
   */
  get isComposite() {
    return isCompositeTokenValue(this.originalValue);
  }
  /**
   * Returns the token value with the references expanded.
   * e.g. {color.gray.100} => var(--colors-gray-100)
   *
   */
  expandReferences() {
    if (!this.hasReference)
      return this.extensions.varRef ?? this.value;
    const references = this.extensions.references ?? {};
    this.value = Object.keys(references).reduce((valueStr, key) => {
      const referenceToken = references[key];
      if (referenceToken.isConditional) {
        return valueStr;
      }
      const value = referenceToken.expandReferences();
      return valueStr.replace(`{${key}}`, value);
    }, this.value);
    delete this.extensions.references;
    return this.value;
  }
  /**
   * Whether this token has a reference to another token
   */
  get isReference() {
    return hasReference(this.originalValue);
  }
  /**
   * Returns the list of references in the token value
   */
  get references() {
    return getReferences(this.originalValue);
  }
  clone() {
    return new _Token({
      name: this.name,
      value: this.value,
      type: this.type,
      path: [...this.path],
      description: this.description,
      extensions: cloneDeep(this.extensions)
    });
  }
  /**
   * Returns an array of tokens per conditions.
   * It is commonly used in semantic tokens, and can have multiple values based on a condition.
   * e.g. primary: { light: '#000', dark: '#fff' }
   */
  getConditionTokens() {
    if (!this.isConditional)
      return;
    const conditions = this.extensions.conditions ?? {};
    const conditionalTokens = [];
    walkObject(conditions, (value, path) => {
      const newPath = path.filter((v) => !isBaseCondition(v));
      if (!newPath.length)
        return;
      const token = this.clone();
      token.value = value;
      token.extensions.condition = newPath.join(":");
      conditionalTokens.push(token);
    });
    return conditionalTokens;
  }
  /**
   * Add more extensions to the token
   */
  setExtensions(extensions) {
    this.extensions = { ...this.extensions, ...extensions };
    this.setType();
    return this;
  }
  setType() {
    if (this.type)
      return;
    if (this.extensions.category) {
      this.type = TOKEN_TYPES[this.extensions.category];
    }
  }
};
function cloneDeep(value) {
  if (value instanceof Token) {
    return value.clone();
  }
  if (Array.isArray(value)) {
    return value.map((child) => cloneDeep(child));
  }
  if (typeof value === "object" && value !== null) {
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, cloneDeep(v)]));
  }
  return value;
}
var TOKEN_TYPES = {
  colors: "color",
  spacing: "dimension",
  sizing: "dimension",
  shadows: "shadow",
  fonts: "fontFamily",
  fontSizes: "fontSize",
  fontWeights: "fontWeight",
  letterSpacings: "letterSpacing",
  durations: "duration",
  transitions: "transition",
  radii: "borderRadius",
  gradients: "gradient",
  easings: "cubicBezier",
  borders: "border",
  components: "cti",
  assets: "asset"
};

// src/dictionary.ts
function expandBreakpoints(breakpoints) {
  if (!breakpoints)
    return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: mapObject(breakpoints, (value) => ({ value })),
    sizes: Object.fromEntries(Object.entries(breakpoints).map(([key, value]) => [`breakpoint-${key}`, { value }]))
  };
}
function filterDefault(path) {
  if (path[0] === "DEFAULT")
    return path;
  return path.filter((item) => item !== "DEFAULT");
}
var TokenDictionary = class {
  allTokens = [];
  prefix;
  hash;
  get allNames() {
    return Array.from(new Set(this.allTokens.map((token) => token.name)));
  }
  constructor(options) {
    const { tokens = {}, semanticTokens = {}, breakpoints, prefix, hash } = options;
    const breakpointTokens = expandBreakpoints(breakpoints);
    const computedTokens = compact({
      ...tokens,
      breakpoints: breakpointTokens.breakpoints,
      sizes: {
        ...tokens.sizes,
        ...breakpointTokens.sizes
      }
    });
    this.prefix = prefix;
    this.hash = hash;
    walkObject2(
      computedTokens,
      (token, path) => {
        path = filterDefault(path);
        assertTokenFormat(token);
        const category = path[0];
        const name = path.join(".");
        const node = new Token({ ...token, name, path });
        node.setExtensions({
          category,
          prop: path.slice(1).join(".")
        });
        this.allTokens.push(node);
      },
      { stop: isToken }
    );
    walkObject2(
      semanticTokens,
      (token, path) => {
        path = filterDefault(path);
        assertTokenFormat(token);
        const category = path[0];
        const name = path.join(".");
        const normalizedToken = isString(token.value) || isCompositeTokenValue(token.value) ? { value: { base: token.value } } : token;
        const { value, ...restData } = normalizedToken;
        const node = new Token({
          ...restData,
          name,
          value: value.base || "",
          path
        });
        node.setExtensions({
          category,
          conditions: value,
          prop: path.slice(1).join(".")
        });
        this.allTokens.push(node);
      },
      { stop: isToken }
    );
  }
  getByName = memo((name) => {
    for (const token of this.allTokens) {
      if (token.name === name)
        return token;
    }
  });
  transforms = /* @__PURE__ */ new Map();
  registerTransform(...transforms2) {
    transforms2.forEach((transform) => {
      transform.type ||= "value";
      transform.enforce ||= "pre";
      this.transforms.set(transform.name, transform);
    });
    return this;
  }
  execTransform(name) {
    const transform = this.transforms.get(name);
    if (!transform)
      return;
    this.allTokens.forEach((token) => {
      if (token.extensions.hasReference)
        return;
      if (typeof transform.match === "function" && !transform.match(token))
        return;
      const exec = (v) => transform.transform(v, { prefix: this.prefix, hash: this.hash });
      const transformed = exec(token);
      match(transform).with({ type: "extensions" }, () => {
        token.setExtensions(transformed);
      }).with({ type: "value" }, () => {
        token.value = transformed;
        if (token.isComposite) {
          token.originalValue = transformed;
        }
        if (token.extensions.conditions) {
          const conditions = token.extensions.conditions;
          const transformedConditions = walkObject2(conditions, (value) => exec({ value }), {
            stop: isCompositeTokenValue
          });
          token.setExtensions({
            conditions: transformedConditions
          });
        }
      }).otherwise(() => {
        token[transform.type] = transformed;
      });
    });
  }
  transformTokens(enforce) {
    this.transforms.forEach((transform) => {
      if (transform.enforce === enforce) {
        this.execTransform(transform.name);
      }
    });
    return this;
  }
  middlewares = [];
  registerMiddleware(...middlewares2) {
    for (const middleware of middlewares2) {
      middleware.enforce ||= "pre";
      this.middlewares.push(middleware);
    }
    return this;
  }
  applyMiddlewares(enforce) {
    this.middlewares.forEach((middleware) => {
      if (middleware.enforce === enforce) {
        middleware.transform(this, { prefix: this.prefix, hash: this.hash });
      }
    });
  }
  getReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref) => this.getByName(ref)).filter(Boolean);
  }
  usesReference(value) {
    if (!isString(value))
      return false;
    return this.getReferences(value).length > 0;
  }
  addReferences() {
    this.allTokens.forEach((token) => {
      if (!this.usesReference(token.value))
        return;
      const references = this.getReferences(token.value);
      token.setExtensions({
        references: references.reduce((object, reference) => {
          object[reference.name] = reference;
          return object;
        }, {})
      });
    });
    return this;
  }
  filter(pattern) {
    const predicate = typeof pattern === "function" ? pattern : isMatching2(pattern);
    return this.allTokens.filter(predicate);
  }
  addConditionalTokens() {
    const tokens = [];
    this.allTokens.forEach((token) => {
      tokens.push(token);
      const conditionalTokens = token.getConditionTokens();
      if (conditionalTokens && conditionalTokens.length > 0) {
        tokens.push(...conditionalTokens);
      }
    });
    this.allTokens = tokens;
    return this;
  }
  expandReferences() {
    this.allTokens.forEach((token) => {
      token.expandReferences();
    });
    return this;
  }
  build() {
    this.applyMiddlewares("pre");
    this.transformTokens("pre");
    this.addConditionalTokens();
    this.addReferences();
    this.expandReferences();
    this.applyMiddlewares("post");
    this.transformTokens("post");
  }
  get isEmpty() {
    return this.allTokens.length === 0;
  }
};

// src/format.ts
import { getDotPath } from "@pandacss/shared";
var formats = {
  groupByCondition(dictionary) {
    const grouped = /* @__PURE__ */ new Map();
    dictionary.allTokens.forEach((token) => {
      const { condition } = token.extensions;
      if (!condition)
        return;
      grouped.get(condition) || grouped.set(condition, /* @__PURE__ */ new Set());
      grouped.set(condition, grouped.get(condition).add(token));
    });
    return grouped;
  },
  groupByColorPalette(dictionary) {
    const grouped = /* @__PURE__ */ new Map();
    dictionary.allTokens.forEach((token) => {
      const { colorPalette, colorPaletteRoots } = token.extensions;
      if (!colorPalette || token.extensions.isVirtual)
        return;
      colorPaletteRoots.forEach((colorPaletteRoot) => {
        grouped.get(colorPaletteRoot) || grouped.set(colorPaletteRoot, /* @__PURE__ */ new Map());
        const virtualName = token.name.replace(colorPaletteRoot, "colorPalette");
        const virtualToken = dictionary.getByName(virtualName);
        if (!virtualToken)
          return;
        const virtualVar = virtualToken.extensions.var;
        grouped.get(colorPaletteRoot).set(virtualVar, token.extensions.varRef);
      });
    });
    return grouped;
  },
  groupByCategory(dictionary) {
    const grouped = /* @__PURE__ */ new Map();
    dictionary.allTokens.forEach((token) => {
      const { category, prop } = token.extensions;
      if (!category)
        return;
      grouped.get(category) || grouped.set(category, /* @__PURE__ */ new Map());
      grouped.set(category, grouped.get(category).set(prop, token));
    });
    return grouped;
  },
  getFlattenedValues(dictionary) {
    const grouped = formats.groupByCategory(dictionary);
    const result = /* @__PURE__ */ new Map();
    grouped.forEach((tokens, category) => {
      result.get(category) || result.set(category, /* @__PURE__ */ new Map());
      tokens.forEach((token) => {
        const { prop, varRef, isNegative } = token.extensions;
        const value = isNegative ? token.isConditional ? token.originalValue : token.value : varRef;
        result.set(category, result.get(category).set(prop, value));
      });
    });
    return result;
  },
  getVars(dictionary) {
    const grouped = formats.groupByCondition(dictionary);
    const result = /* @__PURE__ */ new Map();
    grouped.forEach((tokens, condition) => {
      result.get(condition) || result.set(condition, /* @__PURE__ */ new Map());
      tokens.forEach((token) => {
        if (token.extensions.isNegative || token.extensions.isVirtual)
          return;
        result.get(condition).set(token.extensions.var, token.value);
      });
    });
    return result;
  },
  createVarGetter(dictionary) {
    const flatValues = mapToJson(formats.getFlattenedValues(dictionary));
    return function getToken(path, fallback) {
      return getDotPath(flatValues, path, fallback);
    };
  },
  getColorPaletteValues(dictionary) {
    const values = /* @__PURE__ */ new Set();
    dictionary.allTokens.forEach((token) => {
      const { colorPalette } = token.extensions;
      if (!colorPalette || token.extensions.isVirtual)
        return;
      values.add(colorPalette);
    });
    return values;
  }
};

// src/middleware.ts
import { calc, cssVar, toPx } from "@pandacss/shared";
var addNegativeTokens = {
  enforce: "pre",
  transform(dictionary, { prefix, hash }) {
    const tokens = dictionary.filter({
      extensions: { category: "spacing" }
    });
    tokens.forEach((token) => {
      const originalPath = [...token.path];
      const originalVar = cssVar(originalPath.join("-"), { prefix, hash });
      if (token.value === "0rem") {
        return;
      }
      const node = token.clone();
      node.setExtensions({
        isNegative: true,
        prop: `-${token.extensions.prop}`,
        originalPath
      });
      node.value = calc.negate(originalVar);
      const last = node.path.at(-1);
      if (last != null) {
        node.path[node.path.length - 1] = `-${last}`;
      }
      if (node.path) {
        node.name = node.path.join(".");
      }
      dictionary.allTokens.push(node);
    });
  }
};
var units = /* @__PURE__ */ new Set(["spacing", "sizes", "borderWidths", "fontSizes", "radii"]);
var addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.filter((token) => {
      return units.has(token.extensions.category) && !token.extensions.isNegative;
    });
    tokens.forEach((token) => {
      token.setExtensions({
        pixelValue: toPx(token.value)
      });
    });
  }
};
var addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.filter({
      extensions: { category: "colors" }
    });
    const keys = /* @__PURE__ */ new Set();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token) => {
      const { colorPalette, colorPaletteRoots, colorPaletteTokenKeys } = token.extensions;
      if (!colorPalette)
        return;
      colorPaletteTokenKeys.forEach(keys.add, keys);
      colorPaletteRoots.forEach((colorPaletteRoot) => {
        const colorPaletteList = colorPalettes.get(colorPaletteRoot) || [];
        colorPaletteList.push(token);
        colorPalettes.set(colorPaletteRoot, colorPaletteList);
      });
    });
    keys.forEach((key) => {
      const node = new Token({
        name: ["colors.colorPalette", key].filter(Boolean).join("."),
        value: ["colors.colorPalette", key].filter(Boolean).join("."),
        path: ["colors", "colorPalette", ...key.split(".")]
      });
      node.setExtensions({
        category: "colors",
        prop: ["colorPalette", key].filter(Boolean).join("."),
        isVirtual: true
      });
      dictionary.allTokens.push(node);
    });
    dictionary.transformTokens("pre");
  }
};
var removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter((token) => token.value !== "");
  }
};
var middlewares = [addNegativeTokens, addVirtualPalette, removeEmptyTokens, addPixelUnit];

// src/transform.ts
import { cssVar as cssVar2, isString as isString2 } from "@pandacss/shared";
import { P as P2, match as match2 } from "ts-pattern";

// src/mini-svg-uri.ts
var shorterNames = {
  aqua: /#00ffff(ff)?(?!\w)|#0ff(f)?(?!\w)/gi,
  azure: /#f0ffff(ff)?(?!\w)/gi,
  beige: /#f5f5dc(ff)?(?!\w)/gi,
  bisque: /#ffe4c4(ff)?(?!\w)/gi,
  black: /#000000(ff)?(?!\w)|#000(f)?(?!\w)/gi,
  blue: /#0000ff(ff)?(?!\w)|#00f(f)?(?!\w)/gi,
  brown: /#a52a2a(ff)?(?!\w)/gi,
  coral: /#ff7f50(ff)?(?!\w)/gi,
  cornsilk: /#fff8dc(ff)?(?!\w)/gi,
  crimson: /#dc143c(ff)?(?!\w)/gi,
  cyan: /#00ffff(ff)?(?!\w)|#0ff(f)?(?!\w)/gi,
  darkblue: /#00008b(ff)?(?!\w)/gi,
  darkcyan: /#008b8b(ff)?(?!\w)/gi,
  darkgrey: /#a9a9a9(ff)?(?!\w)/gi,
  darkred: /#8b0000(ff)?(?!\w)/gi,
  deeppink: /#ff1493(ff)?(?!\w)/gi,
  dimgrey: /#696969(ff)?(?!\w)/gi,
  gold: /#ffd700(ff)?(?!\w)/gi,
  green: /#008000(ff)?(?!\w)/gi,
  grey: /#808080(ff)?(?!\w)/gi,
  honeydew: /#f0fff0(ff)?(?!\w)/gi,
  hotpink: /#ff69b4(ff)?(?!\w)/gi,
  indigo: /#4b0082(ff)?(?!\w)/gi,
  ivory: /#fffff0(ff)?(?!\w)/gi,
  khaki: /#f0e68c(ff)?(?!\w)/gi,
  lavender: /#e6e6fa(ff)?(?!\w)/gi,
  lime: /#00ff00(ff)?(?!\w)|#0f0(f)?(?!\w)/gi,
  linen: /#faf0e6(ff)?(?!\w)/gi,
  maroon: /#800000(ff)?(?!\w)/gi,
  moccasin: /#ffe4b5(ff)?(?!\w)/gi,
  navy: /#000080(ff)?(?!\w)/gi,
  oldlace: /#fdf5e6(ff)?(?!\w)/gi,
  olive: /#808000(ff)?(?!\w)/gi,
  orange: /#ffa500(ff)?(?!\w)/gi,
  orchid: /#da70d6(ff)?(?!\w)/gi,
  peru: /#cd853f(ff)?(?!\w)/gi,
  pink: /#ffc0cb(ff)?(?!\w)/gi,
  plum: /#dda0dd(ff)?(?!\w)/gi,
  purple: /#800080(ff)?(?!\w)/gi,
  red: /#ff0000(ff)?(?!\w)|#f00(f)?(?!\w)/gi,
  salmon: /#fa8072(ff)?(?!\w)/gi,
  seagreen: /#2e8b57(ff)?(?!\w)/gi,
  seashell: /#fff5ee(ff)?(?!\w)/gi,
  sienna: /#a0522d(ff)?(?!\w)/gi,
  silver: /#c0c0c0(ff)?(?!\w)/gi,
  skyblue: /#87ceeb(ff)?(?!\w)/gi,
  snow: /#fffafa(ff)?(?!\w)/gi,
  tan: /#d2b48c(ff)?(?!\w)/gi,
  teal: /#008080(ff)?(?!\w)/gi,
  thistle: /#d8bfd8(ff)?(?!\w)/gi,
  tomato: /#ff6347(ff)?(?!\w)/gi,
  violet: /#ee82ee(ff)?(?!\w)/gi,
  wheat: /#f5deb3(ff)?(?!\w)/gi,
  white: /#ffffff(ff)?(?!\w)|#fff(f)?(?!\w)/gi
};
var REGEX = {
  whitespace: /\s+/g,
  urlHexPairs: /%[\dA-F]{2}/g,
  quotes: /"/g
};
function collapseWhitespace(str) {
  return str.trim().replace(REGEX.whitespace, " ");
}
function dataURIPayload(string) {
  return encodeURIComponent(string).replace(REGEX.urlHexPairs, specialHexEncode);
}
function colorCodeToShorterNames(string) {
  objectKeys(shorterNames).forEach((key) => {
    if (shorterNames[key].test(string)) {
      string = string.replace(shorterNames[key], key);
    }
  });
  return string;
}
function specialHexEncode(match3) {
  switch (match3) {
    case "%20":
      return " ";
    case "%3D":
      return "=";
    case "%3A":
      return ":";
    case "%2F":
      return "/";
    default:
      return match3.toLowerCase();
  }
}
function svgToDataUri(svgString) {
  if (typeof svgString !== "string") {
    throw new TypeError("Expected a string, but received " + typeof svgString);
  }
  if (svgString.charCodeAt(0) === 65279) {
    svgString = svgString.slice(1);
  }
  const body = colorCodeToShorterNames(collapseWhitespace(svgString)).replace(REGEX.quotes, "'");
  return "data:image/svg+xml," + dataURIPayload(body);
}
var objectKeys = (obj) => Object.keys(obj);

// src/transform.ts
var transformShadow = {
  name: "tokens/shadow",
  match: (token) => token.extensions.category === "shadows",
  transform(token, opts) {
    if (isString2(token.value)) {
      return token.value;
    }
    if (Array.isArray(token.value)) {
      return token.value.map((value) => this.transform({ value }, opts)).join(", ");
    }
    if (isCompositeShadow(token.value)) {
      const { offsetX, offsetY, blur, spread, color, inset } = token.value;
      return `${inset ? "inset " : ""}${offsetX}px ${offsetY}px ${blur}px ${spread}px ${color}`;
    }
    return token.value;
  }
};
var transformGradient = {
  name: "tokens/gradient",
  match: (token) => token.extensions.category === "gradients",
  transform(token) {
    if (isString2(token.value)) {
      return token.value;
    }
    if (isCompositeGradient(token.value)) {
      const { type, stops, placement } = token.value;
      const rawStops = stops.map((stop) => {
        if (isString2(stop))
          return stop;
        const { color, position } = stop;
        return `${color} ${position}px`;
      });
      return `${type}-gradient(${placement}, ${rawStops.join(", ")})`;
    }
    return token.value;
  }
};
var transformFonts = {
  name: "tokens/fonts",
  match: (token) => token.extensions.category === "fonts",
  transform(token) {
    if (Array.isArray(token.value)) {
      return token.value.join(", ");
    }
    return token.value;
  }
};
var transformEasings = {
  name: "tokens/easings",
  match: (token) => token.extensions.category === "easings",
  transform(token) {
    if (isString2(token.value)) {
      return token.value;
    }
    if (Array.isArray(token.value)) {
      return `cubic-bezier(${token.value.join(", ")})`;
    }
    return token.value;
  }
};
var transformBorders = {
  name: "tokens/borders",
  match: (token) => token.extensions.category === "borders",
  transform(token) {
    if (isString2(token.value)) {
      return token.value;
    }
    if (isCompositeBorder(token.value)) {
      const { width, style, color } = token.value;
      return `${width}px ${style} ${color}`;
    }
    return token.value;
  }
};
var transformAssets = {
  name: "tokens/assets",
  match: (token) => token.extensions.category === "assets",
  transform(token) {
    const raw = token.value;
    return match2(raw).with(P2.string, (value) => value).with({ type: "url" }, ({ value }) => `url('${value}')`).with({ type: "svg" }, ({ value }) => `url('${svgToDataUri(value)})'`).exhaustive();
  }
};
var addCssVariables = {
  type: "extensions",
  name: "tokens/css-var",
  transform(token, { prefix, hash }) {
    const { isNegative, originalPath } = token.extensions;
    const pathValue = isNegative ? originalPath : token.path;
    const variable = cssVar2(pathValue.filter(Boolean).join("-"), { prefix, hash });
    return {
      var: variable.var,
      varRef: variable.ref
    };
  }
};
var addConditionalCssVariables = {
  enforce: "post",
  name: "tokens/conditionals",
  transform(token, { prefix, hash }) {
    const refs = getReferences(token.value);
    if (!refs.length)
      return token.value;
    refs.forEach((ref) => {
      const variable = cssVar2(ref.split(".").join("-"), { prefix, hash }).ref;
      token.value = token.value.replace(`{${ref}}`, variable);
    });
    return token.value;
  }
};
var addColorPalette = {
  type: "extensions",
  name: "tokens/colors/colorPalette",
  match(token) {
    return token.extensions.category === "colors" && !token.extensions.isVirtual;
  },
  transform(token) {
    let tokenPathClone = [...token.path];
    tokenPathClone.pop();
    tokenPathClone.shift();
    if (tokenPathClone.length === 0) {
      const newPath = [...token.path];
      newPath.shift();
      tokenPathClone = newPath;
    }
    if (tokenPathClone.length === 0) {
      return {};
    }
    const colorPaletteRoots = tokenPathClone.reduce((acc, _, i, arr) => {
      const next = arr.slice(0, i + 1).join(".");
      acc.push(next);
      return acc;
    }, []);
    const colorPaletteRoot = tokenPathClone[0];
    const colorPalette = tokenPathClone.join(".");
    const colorPaletteTokenKeys = token.path.slice(token.path.indexOf(colorPaletteRoot) + 1).reduce((acc, _, i, arr) => {
      acc.push(arr.slice(i).join("."));
      return acc;
    }, []);
    if (colorPaletteTokenKeys.length === 0) {
      colorPaletteTokenKeys.push("");
    }
    return {
      colorPalette,
      colorPaletteRoots,
      colorPaletteTokenKeys
    };
  }
};
var transforms = [
  transformShadow,
  transformGradient,
  transformFonts,
  transformEasings,
  transformBorders,
  transformAssets,
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];

// src/create-dictionary.ts
var TokenDictionary2 = class extends TokenDictionary {
  constructor(options) {
    super(options);
    this.registerTransform(...transforms);
    this.registerMiddleware(...middlewares);
    this.build();
  }
  get get() {
    return formats.createVarGetter(this);
  }
  get conditionMap() {
    return formats.groupByCondition(this);
  }
  get categoryMap() {
    return formats.groupByCategory(this);
  }
  get values() {
    return formats.getFlattenedValues(this);
  }
  get colorPalettes() {
    return mapToJson2(formats.groupByColorPalette(this));
  }
  get vars() {
    return formats.getVars(this);
  }
  getValue(path) {
    const result = this.values.get(path);
    if (result != null) {
      return Object.fromEntries(result);
    }
  }
  getTokenVar(path) {
    const json = mapToJson2(this.values);
    return getDotPath2(json, path);
  }
};
export {
  Token,
  TokenDictionary2 as TokenDictionary
};
