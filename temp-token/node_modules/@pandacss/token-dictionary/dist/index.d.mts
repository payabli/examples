import { Tokens, SemanticTokens } from '@pandacss/types';

type TokenStatus = 'deprecated' | 'experimental' | 'new';
interface ExtensionData {
    status?: TokenStatus;
    category?: string;
    references?: TokenReferences;
    condition?: string;
    conditions?: TokenConditions;
}
interface TokenConditions {
    [key: string]: string;
}
interface TokenReferences {
    [key: string]: Token;
}
type TokenExtensions = ExtensionData & {
    [key: string]: any;
};
interface ExtendedToken {
    name: string;
    value: any;
    type?: string;
    path?: string[];
    description?: string;
    extensions?: TokenExtensions;
}
/**
 * Represents a design token in the dictionary
 */
declare class Token {
    name: string;
    value: any;
    originalValue: any;
    path: string[];
    type?: string;
    description?: string;
    extensions: TokenExtensions;
    constructor(data: ExtendedToken);
    /**
     * The unique identifier of the token.
     */
    get id(): string;
    /**
     * Whether the token is a conditional token.
     * Conditional tokens are tokens that have multiple values based on a condition.
     */
    get isConditional(): boolean;
    /**
     * Whether the token has a reference in its value.
     * e.g. {color.gray.100}
     */
    get hasReference(): boolean;
    /**
     * Whether the token is a complex or composite token.
     */
    get isComposite(): boolean;
    /**
     * Returns the token value with the references expanded.
     * e.g. {color.gray.100} => var(--colors-gray-100)
     *
     */
    expandReferences(): string;
    /**
     * Whether this token has a reference to another token
     */
    get isReference(): boolean;
    /**
     * Returns the list of references in the token value
     */
    get references(): string[];
    clone(): Token;
    /**
     * Returns an array of tokens per conditions.
     * It is commonly used in semantic tokens, and can have multiple values based on a condition.
     * e.g. primary: { light: '#000', dark: '#fff' }
     */
    getConditionTokens(): Token[] | undefined;
    /**
     * Add more extensions to the token
     */
    setExtensions(extensions: TokenExtensions): this;
    setType(): void;
}

type EnforcePhase = 'pre' | 'post';
interface Options {
    prefix?: string;
    hash?: boolean;
}
interface TokenTransformer {
    name: string;
    enforce?: EnforcePhase;
    type?: 'value' | 'name' | 'extensions';
    match?: (token: Token) => boolean;
    transform: (token: Token, options: Options) => any;
}
interface TokenDictionaryOptions {
    tokens?: Tokens;
    semanticTokens?: SemanticTokens;
    breakpoints?: Record<string, string>;
    prefix?: string;
    hash?: boolean;
}
interface TokenMiddleware {
    enforce?: EnforcePhase;
    transform: (dict: TokenDictionary$1, options: Options) => void;
}
declare class TokenDictionary$1 {
    allTokens: Token[];
    prefix: string | undefined;
    hash: boolean | undefined;
    get allNames(): string[];
    constructor(options: TokenDictionaryOptions);
    getByName: (name: string) => Token | undefined;
    private transforms;
    registerTransform(...transforms: TokenTransformer[]): this;
    private execTransform;
    transformTokens(enforce: EnforcePhase): this;
    private middlewares;
    registerMiddleware(...middlewares: TokenMiddleware[]): this;
    applyMiddlewares(enforce: EnforcePhase): void;
    getReferences(value: string): Token[];
    usesReference(value: any): boolean;
    addReferences(): this;
    filter(pattern: Partial<Token> | ((token: Token) => boolean)): Token[];
    addConditionalTokens(): this;
    expandReferences(): this;
    build(): void;
    get isEmpty(): boolean;
}

declare class TokenDictionary extends TokenDictionary$1 {
    constructor(options: TokenDictionaryOptions);
    get get(): (path: string, fallback?: string | number | undefined) => string;
    get conditionMap(): Map<string, Set<Token>>;
    get categoryMap(): Map<string, Map<string, Token>>;
    get values(): Map<string, Map<string, string>>;
    get colorPalettes(): {
        clear: never;
        delete: never;
        forEach: never;
        get: never;
        has: never;
        set: never;
        readonly size: never;
        entries: never;
        keys: never;
        values: never;
        [Symbol.iterator]: never;
        readonly [Symbol.toStringTag]: never;
    };
    get vars(): Map<string, Map<string, string>>;
    getValue(path: string): {
        [k: string]: string;
    } | undefined;
    getTokenVar(path: string): any;
}

export { Token, TokenDictionary };
