"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AtomicRule: () => AtomicRule,
  Breakpoints: () => Breakpoints,
  Conditions: () => Conditions,
  Layers: () => Layers,
  Recipes: () => Recipes,
  Stylesheet: () => Stylesheet,
  Utility: () => Utility,
  assignCompositions: () => assignCompositions,
  expandCssFunctions: () => expandCssFunctions,
  expandNestedCss: () => expandNestedCss,
  extractParentSelectors: () => extractParentSelectors,
  getStaticCss: () => getStaticCss,
  isSlotRecipe: () => isSlotRecipe,
  optimizeCss: () => optimizeCss,
  prettifyCss: () => prettifyCss,
  sharedHooks: () => sharedHooks,
  toCss: () => toCss,
  toKeyframeCss: () => toKeyframeCss
});
module.exports = __toCommonJS(src_exports);

// src/atomic-rule.ts
var import_shared4 = require("@pandacss/shared");
var import_postcss4 = require("postcss");

// src/to-css.ts
var import_postcss3 = __toESM(require("postcss"));
var import_postcss_nested = __toESM(require("postcss-nested"));

// src/post-css-js/objectify.ts
var import_shared2 = require("@pandacss/shared");

// src/unitless.ts
var import_shared = require("@pandacss/shared");
var keys = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  msGridRow: true,
  msGridRowSpan: true,
  msGridColumn: true,
  msGridColumnSpan: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  scale: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  WebkitLineClamp: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var unitlessProperties = /* @__PURE__ */ new Set();
Object.keys(keys).forEach((key) => {
  unitlessProperties.add(key);
  unitlessProperties.add((0, import_shared.hypenateProperty)(key));
});

// src/post-css-js/objectify.ts
function atRule(node) {
  if (typeof node.nodes === "undefined")
    return true;
  return objectify(node);
}
function objectify(node) {
  let name;
  const result = {};
  node.each((child) => {
    if (child.type === "atrule") {
      name = "@" + child.name;
      if (child.params)
        name += " " + child.params;
      if (typeof result[name] === "undefined") {
        result[name] = atRule(child);
      } else if (Array.isArray(result[name])) {
        result[name].push(atRule(child));
      } else {
        result[name] = [result[name], atRule(child)];
      }
    } else if (child.type === "rule") {
      const body = objectify(child);
      if (result[child.selector]) {
        for (const i in body) {
          result[child.selector][i] = body[i];
        }
      } else {
        result[child.selector] = body;
      }
    } else if (child.type === "decl") {
      if (child.prop[0] === "-" && child.prop[1] === "-") {
        name = child.prop;
      } else {
        name = (0, import_shared2.camelCaseProperty)(child.prop);
      }
      let value = child.value;
      if (!isNaN(Number(value)) && unitlessProperties.has(name)) {
        value = parseFloat(child.value);
      }
      if (child.important)
        value += " !important";
      if (typeof result[name] === "undefined") {
        result[name] = value;
      } else if (Array.isArray(result[name])) {
        result[name].push(value);
      } else {
        result[name] = [result[name], value];
      }
    }
  });
  return result;
}

// src/post-css-js/parse.ts
var import_shared3 = require("@pandacss/shared");
var import_postcss = __toESM(require("postcss"));
var IMPORTANT = /\s*!important\s*$/i;
function decl(parent, name, value) {
  if (value === false || value == null)
    return;
  const isCssVar = name.startsWith("--");
  if (!isCssVar) {
    name = (0, import_shared3.hypenateProperty)(name);
  }
  if (typeof value === "number") {
    if (value === 0 || unitlessProperties.has(name) || isCssVar) {
      value = value.toString();
    } else {
      value = `${value}px`;
    }
  }
  if (name === "css-float")
    name = "float";
  if (IMPORTANT.test(value)) {
    value = value.replace(IMPORTANT, "");
    parent.push(import_postcss.default.decl({ prop: name, value, important: true }));
  } else {
    parent.push(import_postcss.default.decl({ prop: name, value }));
  }
}
function atRule2(parent, parts, value) {
  if (!parts)
    return;
  const node = import_postcss.default.atRule({ name: parts[1], params: parts[3] || "" });
  if (typeof value === "object") {
    node.nodes = [];
    parse(value, node);
  }
  parent.push(node);
}
var AT_RULE = /@(\S+)(\s+([\W\w]*)\s*)?/;
function parse(obj, parent) {
  let name, value, node;
  for (name in obj) {
    value = obj[name];
    if (value === null || typeof value === "undefined") {
      continue;
    } else if (name[0] === "@") {
      const parts = name.match(AT_RULE);
      if (Array.isArray(value)) {
        for (const i of value) {
          atRule2(parent, parts, i);
        }
      } else {
        atRule2(parent, parts, value);
      }
    } else if (Array.isArray(value)) {
      for (const i of value) {
        decl(parent, name, i);
      }
    } else if (typeof value === "object") {
      node = import_postcss.default.rule({ selector: name });
      parse(value, node);
      parent.push(node);
    } else {
      decl(parent, name, value);
    }
  }
}
var postCssPlugin = (obj) => {
  const root = import_postcss.default.root();
  parse(obj, root);
  return root;
};
var parser = postCssPlugin;

// src/post-css-js/index.ts
var postCssJs = {
  parser,
  objectify
};

// src/safe-parse.ts
var import_postcss2 = __toESM(require("postcss"));
function safeParse(str) {
  try {
    return import_postcss2.default.parse(str);
  } catch (error) {
    return import_postcss2.default.root();
  }
}

// src/to-css.ts
function toCss(styles, { important } = {}) {
  const result = (0, import_postcss3.default)([
    (0, import_postcss_nested.default)({
      bubble: ["breakpoint"]
    })
  ]).process(styles, {
    parser: postCssJs.parser
  });
  if (important) {
    result.root.walkDecls((decl2) => {
      decl2.important = true;
    });
  }
  return result;
}
function cssToJs(css) {
  return postCssJs.objectify(safeParse(css));
}

// src/atomic-rule.ts
var urlRegex = /^https?:\/\//;
var AtomicRule = class {
  constructor(context, fn) {
    this.context = context;
    this.fn = fn;
  }
  hashFn = (conditions, className) => {
    const { conditions: cond, hash, utility } = this.context;
    let result;
    if (hash) {
      const baseArray = [...cond.finalize(conditions), className];
      result = utility.formatClassName((0, import_shared4.toHash)(baseArray.join(":")));
    } else {
      const baseArray = [...cond.finalize(conditions), utility.formatClassName(className)];
      result = baseArray.join(":");
    }
    return (0, import_shared4.esc)(result);
  };
  get rule() {
    return this.context.conditions.rule();
  }
  get transform() {
    return this.context?.transform ?? this.context.utility.transform;
  }
  normalize = (styles, normalizeShorthand = true) => {
    return (0, import_shared4.normalizeStyleObject)(styles, this.context, normalizeShorthand);
  };
  process = (options) => {
    const { styles: styleObject } = options;
    const { conditions: cond } = this.context;
    if (typeof styleObject !== "object")
      return;
    const rule = this.rule;
    (0, import_shared4.walkObject)(styleObject, (value, paths) => {
      if (value == null)
        return;
      if (urlRegex.test(value)) {
        return;
      }
      const important = (0, import_shared4.isImportant)(value);
      const [prop, ...allConditions] = cond.shift(paths);
      const conditions = (0, import_shared4.filterBaseConditions)(allConditions);
      const transformed = this.transform(prop, (0, import_shared4.withoutImportant)(value));
      const cssRoot = toCss(transformed.styles, { important });
      rule.nodes = cssRoot.root.nodes;
      if (rule.isEmpty)
        return;
      const selector = this.hashFn(conditions, transformed.className);
      rule.selector = important ? `.${selector}\\!` : `.${selector}`;
      rule.update();
      rule.applyConditions(conditions);
      const styleRule = rule.rule;
      this.fn({ layer: transformed.layer, rule: styleRule });
    });
  };
};
function createRecipeAtomicRule(ctx, slot) {
  return new AtomicRule(ctx, ({ rule, layer }) => {
    if (layer === "_base" && slot) {
      ctx.layers.slotRecipes.base.append(rule);
    } else if (slot) {
      ctx.layers.slotRecipes.root.append(rule);
    } else if (layer === "_base") {
      ctx.layers.recipes.base.append(rule);
    } else {
      ctx.layers.recipes.root.append(rule);
    }
  });
}

// src/breakpoints.ts
var import_shared5 = require("@pandacss/shared");
var Breakpoints = class {
  constructor(breakpoints) {
    this.breakpoints = breakpoints;
  }
  get sorted() {
    return sortBreakpoints(this.breakpoints);
  }
  get values() {
    return Object.fromEntries(this.sorted);
  }
  get keys() {
    return ["base", ...Object.keys(this.values)];
  }
  get = (name) => {
    return this.values[name];
  };
  build = ({ min, max }) => {
    if (min == null && max == null)
      return "";
    return ["screen", min && `(min-width: ${min})`, max && `(max-width: ${max})`].filter(Boolean).join(" and ");
  };
  only = (name) => {
    const { min, max } = this.get(name);
    return this.build({ min, max });
  };
  get ranges() {
    const breakpoints = Object.keys(this.values);
    const permuations = getPermutations(breakpoints);
    const values = breakpoints.flatMap((name) => {
      const value = this.get(name);
      const down = [`${name}Down`, this.build({ max: adjust(value.min) })];
      const up = [name, this.build({ min: value.min })];
      const only = [`${name}Only`, this.only(name)];
      return [up, only, down];
    }).filter(([_, value]) => value !== "").concat(
      permuations.map(([min, max]) => {
        const minValue = this.get(min);
        const maxValue2 = this.get(max);
        return [`${min}To${(0, import_shared5.capitalize)(max)}`, this.build({ min: minValue.min, max: adjust(maxValue2.min) })];
      })
    );
    return Object.fromEntries(values);
  }
  get conditions() {
    const values = Object.entries(this.ranges).map(([key, value]) => {
      return [key, toCondition(key, value)];
    });
    return Object.fromEntries(values);
  }
  getCondition = (key) => {
    return this.conditions[key];
  };
  expandScreenAtRule = (root) => {
    root.walkAtRules("breakpoint", (rule) => {
      const value = this.getCondition(rule.params);
      if (!value) {
        throw rule.error(`No \`${rule.params}\` screen found.`);
      }
      rule.name = "media";
      rule.params = value.params;
    });
  };
};
function adjust(value) {
  const computedMax = parseFloat((0, import_shared5.toPx)(value) ?? "") - 0.04;
  return (0, import_shared5.toEm)(`${computedMax}px`);
}
function sortBreakpoints(breakpoints) {
  return Object.entries(breakpoints).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  }).map(([name, min], index, entries) => {
    let max = null;
    if (index <= entries.length - 1) {
      max = entries[index + 1]?.[1];
    }
    if (max != null) {
      max = adjust(max);
    }
    return [name, { name, min: (0, import_shared5.toEm)(min), max }];
  });
}
var toCondition = (key, value) => ({
  type: "at-rule",
  name: "breakpoint",
  value: key,
  raw: key,
  rawValue: `@media ${value}`,
  params: value
});
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next = values[idx];
    while (next) {
      result.push([current, next]);
      idx++;
      next = values[idx];
    }
  });
  return result;
}

// src/compositions.ts
var import_shared7 = require("@pandacss/shared");

// src/serialize.ts
var import_shared6 = require("@pandacss/shared");
var import_lodash = __toESM(require("lodash.merge"));
function serializeStyle(styleObj, context) {
  const { utility, conditions } = context;
  const rule = conditions.rule();
  const result = {};
  const normalizedObject = (0, import_shared6.normalizeStyleObject)(styleObj, context);
  (0, import_shared6.walkObject)(normalizedObject, (value, paths) => {
    const important = (0, import_shared6.isImportant)(value);
    const [prop, ...allConditions] = conditions.shift(paths);
    const conds = (0, import_shared6.filterBaseConditions)(allConditions);
    const hasConditions = conds.length > 0;
    let { styles } = utility.transform(prop, (0, import_shared6.withoutImportant)(value));
    const cssResult = toCss(styles, { important });
    if (hasConditions) {
      const segments = conditions.segment(conds);
      rule.nodes = cssResult.root.nodes;
      rule.selector = segments.selector.length > 0 ? segments.selector[0] : "&";
      rule.update();
      rule.applyConditions(segments.condition);
      styles = cssToJs(rule.toString());
    } else {
      styles = cssToJs(cssResult.css);
    }
    (0, import_lodash.default)(result, styles);
  });
  return result;
}
function serializeStyles(groupedObject, context) {
  const result = {};
  for (const [scope, styles] of Object.entries(groupedObject)) {
    result[scope] ||= {};
    (0, import_lodash.default)(result[scope], serializeStyle(styles, context));
  }
  return toCss(result).root;
}

// src/compositions.ts
function assignCompositions(compositions, ctx) {
  for (const [key, values] of Object.entries(compositions)) {
    const flatValues = (0, import_shared7.flatten)(values ?? {});
    const config = {
      layer: "compositions",
      className: key,
      values: Object.keys(flatValues),
      transform: (value) => {
        return serializeStyle(flatValues[value], ctx);
      }
    };
    ctx.utility.register(key, config);
  }
}

// src/conditions.ts
var import_logger = require("@pandacss/logger");
var import_shared8 = require("@pandacss/shared");

// src/conditional-rule.ts
var import_postcss5 = __toESM(require("postcss"));
var ConditionalRule = class {
  constructor(conditionsMap) {
    this.conditionsMap = conditionsMap;
  }
  rule;
  selector = "";
  nodes = [];
  get isEmpty() {
    return this.nodes.length === 0;
  }
  update = () => {
    this.rule = import_postcss5.default.rule({ selector: this.selector, nodes: this.nodes });
  };
  applyConditions = (conditions) => {
    const sorted = this.conditionsMap.sort(conditions);
    const rule = import_postcss5.default.rule({ selector: this.selector });
    sorted.forEach((cond) => {
      if (!cond)
        return;
      const selector = cond.rawValue ?? cond.value;
      const last = getDeepestNode(rule);
      const node = last ?? rule;
      node.append(import_postcss5.default.rule({ selector }));
    });
    getDeepestNode(rule)?.append(this.nodes);
    this.rule = rule;
  };
  toString() {
    return this.rule.toString();
  }
};
function getDeepestNode(node) {
  if (node.nodes && node.nodes.length) {
    return getDeepestNode(node.nodes[node.nodes.length - 1]);
  }
  return node;
}

// src/parse-condition.ts
var import_postcss6 = require("postcss");
function parseAtRule(value) {
  const result = safeParse(value);
  const rule = result.nodes[0];
  return {
    type: "at-rule",
    name: rule.name,
    value: rule.params,
    raw: value,
    rawValue: value
  };
}
function parseCondition(condition) {
  if (condition.startsWith("@")) {
    return parseAtRule(condition);
  }
  let type;
  if (condition.startsWith("&")) {
    type = "self-nesting";
  } else if (condition.endsWith(" &")) {
    type = "parent-nesting";
  } else if (condition.includes("&")) {
    type = "combinator-nesting";
  }
  if (type) {
    return { type, value: condition, raw: condition };
  }
}

// src/conditions.ts
var order = ["self-nesting", "combinator-nesting", "parent-nesting", "at-rule"];
var underscoreRegex = /^_/;
var selectorRegex = /&|@/;
var Conditions = class {
  constructor(options) {
    this.options = options;
    const { breakpoints: breakpointValues = {}, conditions = {} } = this.options;
    const breakpoints = new Breakpoints(breakpointValues);
    this.breakpoints = breakpoints;
    const entries = Object.entries(conditions).map(([key, value]) => [`_${key}`, parseCondition(value)]);
    this.values = {
      ...Object.fromEntries(entries),
      ...breakpoints.conditions
    };
  }
  values;
  breakpoints;
  finalize = (paths) => {
    return paths.map((path) => {
      if (this.has(path)) {
        return path.replace(underscoreRegex, "");
      }
      if (selectorRegex.test(path)) {
        return `[${(0, import_shared8.withoutSpace)(path.trim())}]`;
      }
      return path;
    });
  };
  shift = (paths) => {
    return paths.map((path) => path.trim()).sort((a, b) => {
      const aIsCondition = this.isCondition(a);
      const bIsCondition = this.isCondition(b);
      if (aIsCondition && !bIsCondition)
        return 1;
      if (!aIsCondition && bIsCondition)
        return -1;
      if (!aIsCondition && !bIsCondition)
        return -1;
      return 0;
    });
  };
  segment = (paths) => {
    const condition = [];
    const selector = [];
    for (const path of paths) {
      if (this.isCondition(path)) {
        condition.push(path);
      } else {
        selector.push(path);
      }
    }
    return { condition, selector };
  };
  has = (key) => {
    return Object.prototype.hasOwnProperty.call(this.values, key);
  };
  isCondition = (key) => {
    return this.has(key) || !!this.getRaw(key) || (0, import_shared8.isBaseCondition)(key);
  };
  isEmpty = () => {
    return Object.keys(this.values).length === 0;
  };
  get = (key) => {
    const result = this.values[key];
    return result?.rawValue ?? result?.value;
  };
  getRaw = (condition) => {
    try {
      return this.values[condition] ?? parseCondition(condition);
    } catch (error) {
      import_logger.logger.error("core:condition", error);
    }
  };
  sort = (conditions) => {
    const rawConditions = conditions.map(this.getRaw).filter(Boolean);
    return rawConditions.sort((a, b) => order.indexOf(a.type) - order.indexOf(b.type));
  };
  normalize = (condition) => {
    return typeof condition === "string" ? this.getRaw(condition) : condition;
  };
  keys = () => {
    return Object.keys(this.values);
  };
  rule = () => {
    return new ConditionalRule(this);
  };
  saveOne = (key, value) => {
    const parsed = parseCondition(value);
    if (!parsed)
      return;
    this.values[`_${key}`] = parsed;
  };
  remove(key) {
    delete this.values[`_${key}`];
  }
};

// src/is-slot-recipe.ts
var isSlotRecipe = (v) => "slots" in v && Array.isArray(v.slots) && v.slots.length > 0;

// src/keyframes.ts
var import_postcss7 = __toESM(require("postcss"));
function toString(name, definition) {
  return import_postcss7.default.atRule({
    name: "keyframes",
    params: name,
    nodes: toCss(definition).root.nodes
  });
}
function toKeyframeCss(values) {
  const root = import_postcss7.default.root();
  for (const [name, definition] of Object.entries(values)) {
    root.append(toString(name, definition));
  }
  const rule = import_postcss7.default.atRule({
    name: "layer",
    params: "tokens",
    nodes: root.nodes
  });
  return rule.toString();
}

// src/layers.ts
var import_postcss8 = __toESM(require("postcss"));
var Layers = class {
  constructor(names) {
    this.names = names;
    this.root = import_postcss8.default.root();
    this.reset = import_postcss8.default.atRule({ name: "layer", params: names.reset, nodes: [] });
    this.base = import_postcss8.default.atRule({ name: "layer", params: names.base, nodes: [] });
    this.tokens = import_postcss8.default.atRule({ name: "layer", params: names.tokens, nodes: [] });
    this.recipes = {
      root: import_postcss8.default.atRule({ name: "layer", params: names.recipes, nodes: [] }),
      base: import_postcss8.default.atRule({ name: "layer", params: "_base", nodes: [] })
    };
    this.slotRecipes = {
      root: import_postcss8.default.atRule({ name: "layer", params: names.recipes + ".slots", nodes: [] }),
      base: import_postcss8.default.atRule({ name: "layer", params: "_base", nodes: [] })
    };
    this.utilities = {
      root: import_postcss8.default.atRule({ name: "layer", params: names.utilities, nodes: [] }),
      compositions: import_postcss8.default.atRule({ name: "layer", params: "compositions", nodes: [] }),
      custom: (layer) => {
        if (!this.utilityRuleMap.has(layer)) {
          const atRule3 = import_postcss8.default.atRule({ name: "layer", params: layer, nodes: [] });
          this.utilityRuleMap.set(layer, atRule3);
        }
        return this.utilityRuleMap.get(layer);
      }
    };
  }
  root;
  reset;
  base;
  tokens;
  recipes;
  slotRecipes;
  utilities;
  utilityRuleMap = /* @__PURE__ */ new Map();
  getLayer(layer) {
    const { reset, base, tokens, recipes, slotRecipes, utilities } = this;
    switch (layer) {
      case "base":
        return base;
      case "reset":
        return reset;
      case "tokens": {
        return tokens;
      }
      case "recipes": {
        const recipeRoot = import_postcss8.default.root();
        if (recipes.base.nodes.length)
          recipes.root.prepend(recipes.base);
        if (slotRecipes.base.nodes.length)
          slotRecipes.root.prepend(slotRecipes.base);
        if (recipes.root.nodes.length)
          recipeRoot.append(recipes.root);
        if (slotRecipes.root.nodes.length)
          recipeRoot.append(slotRecipes.root);
        return recipeRoot;
      }
      case "utilities": {
        if (utilities.compositions.nodes.length)
          utilities.root.prepend(utilities.compositions);
        this.utilityRuleMap.forEach((rules) => {
          if (rules.nodes.length)
            utilities.root.append(rules);
        });
        return utilities.root;
      }
      default:
        throw new Error(`Unknown layer: ${layer}`);
    }
  }
  insert() {
    const { root } = this;
    const reset = this.getLayer("reset");
    if (reset.nodes.length)
      root.append(reset);
    const base = this.getLayer("base");
    if (base.nodes.length)
      root.append(base);
    const tokens = this.getLayer("tokens");
    if (tokens.nodes.length)
      root.append(tokens);
    const recipes = this.getLayer("recipes");
    if (recipes.nodes.length)
      root.append(recipes);
    const utilities = this.getLayer("utilities");
    if (utilities.nodes.length)
      root.append(utilities);
    return root;
  }
  clean() {
    this.root.removeAll();
  }
  get layerNames() {
    return Object.values(this.names);
  }
  isValidParams(params) {
    const names = new Set(params.split(",").map((name) => name.trim()));
    return names.size >= 5 && this.layerNames.every((name) => names.has(name));
  }
  get params() {
    return `@layer ${this.layerNames.join(", ")};`;
  }
};

// src/optimize.ts
var import_postcss9 = __toESM(require("postcss"));
var import_postcss_discard_duplicates = __toESM(require("postcss-discard-duplicates"));
var import_postcss_discard_empty = __toESM(require("postcss-discard-empty"));
var import_postcss_merge_rules = __toESM(require("postcss-merge-rules"));
var import_postcss_minify_selectors = __toESM(require("postcss-minify-selectors"));
var import_postcss_nested2 = __toESM(require("postcss-nested"));
var import_postcss_normalize_whitespace = __toESM(require("postcss-normalize-whitespace"));

// src/plugins/expand-token-fn.ts
var import_shared9 = require("@pandacss/shared");
var tokenRegex = /token\(([^)]+)\)/g;
var closingParenthesisRegex = /\)$/;
var expandToken = (str, replacer, getterFn) => {
  const value = str.replace(tokenRegex, (_, token) => {
    const [tokenValue, tokenFallback] = token.split(",").map((s) => s.trim());
    const result = [tokenValue, tokenFallback].filter(Boolean).map((s) => getterFn?.(s) ?? (0, import_shared9.esc)(s));
    if (result.length > 1) {
      const [a, b] = result;
      return replacer(a, b);
    }
    return replacer(result[0]);
  });
  return value;
};
var tokenReplacer = (a, b) => b ? a.endsWith(")") ? a.replace(closingParenthesisRegex, `, ${b})`) : `var(${a}, ${b})` : a;
var atRuleReplace = (a, b) => a ?? b;
function expandTokenFn(tokenFn, rawTokenFn) {
  return (root) => {
    root.walk((node) => {
      if (node.type === "decl" && node.value.includes("token(")) {
        node.value = expandToken(node.value, tokenReplacer, tokenFn);
        return;
      }
      if (node.type === "atrule" && node.params.includes("token(")) {
        node.params = expandToken(node.params, atRuleReplace, (path) => rawTokenFn?.(path)?.value);
      }
      if (node.type === "rule" && node.selector.includes("token(")) {
        node.selector = expandToken(node.selector, atRuleReplace, (path) => rawTokenFn?.(path)?.value);
      }
    });
  };
}
expandTokenFn.postcssPlugin = "panda:expand-token-fn";
var expand_token_fn_default = expandTokenFn;

// src/plugins/prettify.ts
function prettifyNode(node, indent = 0) {
  node.each && node.each((child, i) => {
    if (!child.raws.before || !child.raws.before.trim() || child.raws.before.includes("\n")) {
      child.raws.before = `
${node.type !== "rule" && i > 0 ? "\n" : ""}${"  ".repeat(indent)}`;
    }
    prettifyNode(child, indent + 1);
  });
}
function prettify() {
  return (root) => {
    prettifyNode(root);
    if (root.first) {
      root.first.raws.before = "";
    }
  };
}
prettify.postcssPlugin = "panda-prettify";

// src/plugins/sort-css.ts
var styleOrder = [":link", ":visited", ":focus-within", ":focus", ":focus-visible", ":hover", ":active"];
var pseudoSelectorScore = (selector) => {
  const index = styleOrder.findIndex((pseudoClass) => selector.trim().includes(pseudoClass));
  return index + 1;
};
function sortCss() {
  const inner = (root) => {
    const catchAll = [];
    const rules = [];
    const atRules = [];
    root.each((node) => {
      switch (node.type) {
        case "rule": {
          if (node.first?.type === "atrule") {
            atRules.push(node);
          } else {
            rules.push(node);
          }
          break;
        }
        case "atrule": {
          atRules.push(node);
          break;
        }
        default: {
          catchAll.push(node);
        }
      }
    });
    rules.sort((rule1, rule2) => {
      const selector1 = rule1.selectors.length ? rule1.selectors[0] : rule1.selector;
      const selector2 = rule2.selectors.length ? rule2.selectors[0] : rule2.selector;
      return pseudoSelectorScore(selector1) - pseudoSelectorScore(selector2);
    });
    root.nodes = [...catchAll, ...rules, ...atRules];
    root.nodes.forEach((node) => {
      if ("nodes" in node) {
        inner(node);
      }
    });
  };
  return inner;
}
sortCss.postcssPlugin = "panda-sort-css";

// src/plugins/sort-at-rules.ts
var minMaxWidth = /(!?\(\s*min(-device-)?-width)(.|\n)+\(\s*max(-device)?-width/i;
var minWidth = /\(\s*min(-device)?-width/i;
var maxMinWidth = /(!?\(\s*max(-device)?-width)(.|\n)+\(\s*min(-device)?-width/i;
var maxWidth = /\(\s*max(-device)?-width/i;
var isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);
var isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);
var minMaxHeight = /(!?\(\s*min(-device)?-height)(.|\n)+\(\s*max(-device)?-height/i;
var minHeight = /\(\s*min(-device)?-height/i;
var maxMinHeight = /(!?\(\s*max(-device)?-height)(.|\n)+\(\s*min(-device)?-height/i;
var maxHeight = /\(\s*max(-device)?-height/i;
var isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);
var isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);
var isPrint = /print/i;
var isPrintOnly = /^print$/i;
var maxValue = Number.MAX_VALUE;
function getQueryLength(query) {
  let length = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/.exec(query);
  if (length === null && (isMinWidth(query) || isMinHeight(query))) {
    length = /(\d)/.exec(query);
  }
  if (length === "0") {
    return 0;
  }
  if (length === null) {
    return maxValue;
  }
  let number = length[1];
  const unit = length[2];
  switch (unit) {
    case "ch":
      number = parseFloat(number) * 8.8984375;
      break;
    case "em":
    case "rem":
      number = parseFloat(number) * 16;
      break;
    case "ex":
      number = parseFloat(number) * 8.296875;
      break;
    case "px":
      number = parseFloat(number);
      break;
  }
  return +number;
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return function(query) {
    if (doubleTestTrue.test(query)) {
      return true;
    } else if (doubleTestFalse.test(query)) {
      return false;
    }
    return singleTest.test(query);
  };
}
function _testIsPrint(a, b) {
  const isPrintA = isPrint.test(a);
  const isPrintOnlyA = isPrintOnly.test(a);
  const isPrintB = isPrint.test(b);
  const isPrintOnlyB = isPrintOnly.test(b);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) {
      return 1;
    }
    if (isPrintOnlyA && !isPrintOnlyB) {
      return -1;
    }
    return a.localeCompare(b);
  }
  if (isPrintA) {
    return 1;
  }
  if (isPrintB) {
    return -1;
  }
  return null;
}
function createSort(config = {}) {
  const { unitlessMqAlwaysFirst } = config;
  return function sortCSSmq(a, b) {
    const testIsPrint = _testIsPrint(a, b);
    if (testIsPrint !== null) {
      return testIsPrint;
    }
    const minA = isMinWidth(a) || isMinHeight(a);
    const maxA = isMaxWidth(a) || isMaxHeight(a);
    const minB = isMinWidth(b) || isMinHeight(b);
    const maxB = isMaxWidth(b) || isMaxHeight(b);
    if (unitlessMqAlwaysFirst && (!minA && !maxA || !minB && !maxB)) {
      if (!minA && !maxA && !minB && !maxB) {
        return a.localeCompare(b);
      }
      return !minB && !maxB ? 1 : -1;
    } else {
      if (minA && maxB) {
        return -1;
      }
      if (maxA && minB) {
        return 1;
      }
      const lengthA = getQueryLength(a);
      const lengthB = getQueryLength(b);
      if (lengthA === maxValue && lengthB === maxValue) {
        return a.localeCompare(b);
      } else if (lengthA === maxValue) {
        return 1;
      } else if (lengthB === maxValue) {
        return -1;
      }
      if (lengthA > lengthB) {
        if (maxA) {
          return -1;
        }
        return 1;
      }
      if (lengthA < lengthB) {
        if (maxA) {
          return 1;
        }
        return -1;
      }
      return a.localeCompare(b);
    }
  };
}
var sortAtRules = createSort();

// src/plugins/sort-mq.ts
var import_ts_pattern = require("ts-pattern");
function sortMediaQueries() {
  const inner = (root) => {
    root.nodes.sort((a, b) => {
      return (0, import_ts_pattern.match)({ a, b }).with(
        {
          a: { type: "atrule", name: "media" },
          b: { type: "atrule", name: "media" }
        },
        ({ a: a2, b: b2 }) => {
          return sortAtRules(a2.params, b2.params);
        }
      ).with({ a: { type: "atrule", name: "media" }, b: import_ts_pattern.P.any }, () => {
        return 1;
      }).with({ a: import_ts_pattern.P.any, b: { type: "atrule", name: "media" } }, () => {
        return -1;
      }).otherwise(() => {
        return 0;
      });
    });
    root.nodes.forEach((node) => {
      if ("nodes" in node) {
        inner(node);
      }
    });
  };
  return inner;
}
sortMediaQueries.postcssPlugin = "panda-sort-mq";

// src/optimize.ts
function optimizeCss(code, options = {}) {
  const { minify = false } = options;
  const plugins = [
    (0, import_postcss_nested2.default)(),
    sortMediaQueries(),
    (0, import_postcss_discard_duplicates.default)(),
    (0, import_postcss_merge_rules.default)(),
    sortCss(),
    (0, import_postcss_discard_empty.default)()
  ];
  if (minify) {
    plugins.push((0, import_postcss_normalize_whitespace.default)(), (0, import_postcss_minify_selectors.default)());
  } else {
    plugins.push(prettify());
  }
  const { css } = (0, import_postcss9.default)(plugins).process(code);
  return css;
}
function expandCssFunctions(code, options = {}) {
  const { token, raw } = options;
  const { css } = (0, import_postcss9.default)([expand_token_fn_default(token, raw)]).process(code);
  return css;
}
function expandNestedCss(code) {
  const { css } = (0, import_postcss9.default)([(0, import_postcss_nested2.default)(), prettify()]).process(code);
  return css;
}
function prettifyCss(code) {
  const { css } = (0, import_postcss9.default)([prettify()]).process(code);
  return css;
}

// src/recipes.ts
var import_shared10 = require("@pandacss/shared");
var import_lodash2 = __toESM(require("lodash.merge"));
var sharedState = {
  /**
   * The map of recipe names to their resolved class names
   */
  classNames: /* @__PURE__ */ new Map(),
  /**
   * The map of the property to their resolved styles
   */
  styles: /* @__PURE__ */ new Map(),
  /**
   * The map of the recipes with their resolved styles
   */
  nodes: /* @__PURE__ */ new Map(),
  /**
   * The map of recipe key to slot key + slot recipe
   */
  slots: /* @__PURE__ */ new Map()
};
var Recipes = class {
  constructor(recipes = {}, context) {
    this.recipes = recipes;
    this.context = context;
    this.prune();
    this.save();
  }
  /**
   * The map of the recipes to their atomic rules
   */
  rules = /* @__PURE__ */ new Map();
  get keys() {
    return Object.keys(this.recipes);
  }
  getPropKey = (recipe, variant, value) => {
    return `${recipe} (${variant} = ${value})`;
  };
  get separator() {
    return this.context.utility.separator ?? "_";
  }
  getClassName = (className, variant, value) => {
    return `${className}--${variant}${this.separator}${value}`;
  };
  // check this.recipes against sharedState.nodes
  // and remove any recipes (in sharedState) that are no longer in use
  prune = () => {
    const recipeNames = Object.keys(this.recipes);
    const cachedRecipeNames = Array.from(sharedState.nodes.keys());
    const removedRecipes = cachedRecipeNames.filter((name) => !recipeNames.includes(name));
    removedRecipes.forEach((name) => {
      this.remove(name);
    });
  };
  save = () => {
    for (const [name, recipe] of Object.entries(this.recipes)) {
      this.saveOne(name, recipe);
    }
  };
  saveOne = (name, recipe) => {
    if (isSlotRecipe(recipe)) {
      const slots = (0, import_shared10.getSlotRecipes)(recipe);
      const slotsMap = /* @__PURE__ */ new Map();
      Object.entries(slots).forEach(([slot, slotRecipe]) => {
        const slotName = this.getSlotKey(name, slot);
        this.normalize(slotName, slotRecipe);
        slotsMap.set(slotName, slotRecipe);
        this.rules.set(slotName, this.createRule(slotName, true));
      });
      this.assignRecipe(name, recipe);
      sharedState.slots.set(name, slotsMap);
    } else {
      this.assignRecipe(name, this.normalize(name, recipe));
      this.rules.set(name, this.createRule(name));
    }
  };
  remove(name) {
    this.rules.delete(name);
    sharedState.nodes.delete(name);
    sharedState.classNames.delete(name);
    sharedState.styles.delete(name);
  }
  assignRecipe = (name, recipe) => {
    const variantKeys = Object.keys(recipe.variants ?? {});
    const capitalized = (0, import_shared10.capitalize)(name);
    const jsx = recipe.jsx ?? [capitalized];
    if ("slots" in recipe) {
      jsx.push(...recipe.slots.map((slot) => capitalized + "." + (0, import_shared10.capitalize)(slot)));
    }
    const match3 = (0, import_shared10.createRegex)(jsx);
    sharedState.nodes.set(name, {
      ...this.getNames(name),
      jsx,
      type: "recipe",
      variantKeys,
      variantKeyMap: Object.fromEntries(
        Object.entries(recipe.variants ?? {}).map(([key, value]) => {
          return [key, Object.keys(value)];
        })
      ),
      match: match3,
      config: recipe,
      splitProps: (props) => {
        return (0, import_shared10.splitProps)(props, variantKeys);
      },
      props: variantKeys
    });
  };
  getSlotKey = (name, slot) => {
    return `${name}__${slot}`;
  };
  isEmpty = () => {
    return sharedState.nodes.size === 0;
  };
  getNames = (0, import_shared10.memo)((name) => {
    return {
      baseName: name,
      upperName: (0, import_shared10.capitalize)(name),
      dashName: (0, import_shared10.dashCase)(name),
      jsxName: (0, import_shared10.capitalize)(name)
    };
  });
  getRecipe = (0, import_shared10.memo)((name) => {
    return sharedState.nodes.get(name);
  });
  getConfig = (0, import_shared10.memo)((name) => {
    return this.recipes[name];
  });
  find = (0, import_shared10.memo)((jsxName) => {
    return this.details.find((node) => node.match.test(jsxName));
  });
  filter = (0, import_shared10.memo)((jsxName) => {
    return this.details.filter((node) => node.match.test(jsxName));
  });
  get details() {
    return Array.from(sharedState.nodes.values());
  }
  splitProps = (recipeName, props) => {
    const recipe = this.details.find((node) => node.baseName === recipeName);
    if (!recipe)
      return [{}, props];
    return recipe.splitProps(props);
  };
  normalize = (name, config) => {
    const {
      className,
      jsx = [(0, import_shared10.capitalize)(name)],
      base = {},
      variants = {},
      defaultVariants = {},
      description = "",
      compoundVariants = [],
      staticCss = []
    } = config;
    const recipe = {
      ...config,
      jsx,
      className,
      description,
      base: {},
      variants: {},
      defaultVariants,
      compoundVariants,
      staticCss
    };
    recipe.base = this.serialize(base);
    sharedState.styles.set(name, recipe.base);
    sharedState.classNames.set(name, className);
    for (const [key, variant] of Object.entries(variants)) {
      for (const [variantKey, styles] of Object.entries(variant)) {
        const propKey = this.getPropKey(name, key, variantKey);
        const className2 = this.getClassName(config.className, key, variantKey);
        const styleObject = this.serialize(styles);
        sharedState.styles.set(propKey, styleObject);
        sharedState.classNames.set(propKey, className2);
        (0, import_lodash2.default)(recipe.variants, {
          [key]: { [variantKey]: styleObject }
        });
      }
    }
    return recipe;
  };
  serialize = (styleObject) => {
    if (!this.context)
      return styleObject;
    return serializeStyle(styleObject, this.context);
  };
  getTransform = (name) => {
    return (variant, value) => {
      if (value === "__ignore__") {
        return {
          layer: "_base",
          className: sharedState.classNames.get(name),
          styles: sharedState.styles.get(name) ?? {}
        };
      }
      const propKey = this.getPropKey(name, variant, value);
      return {
        className: sharedState.classNames.get(propKey),
        styles: sharedState.styles.get(propKey) ?? {}
      };
    };
  };
  createRule = (name, slot) => {
    if (!this.context) {
      throw new Error("Can't create a rule without a context");
    }
    const context = {
      ...this.context,
      transform: this.getTransform(name)
    };
    const rule = createRecipeAtomicRule(context, slot);
    return rule;
  };
  check = (config, className, variants) => {
    const { defaultVariants = {}, base = {} } = config;
    const styles = Object.assign({ [className]: "__ignore__" }, defaultVariants, variants);
    const keys2 = Object.keys(styles);
    return { styles, isEmpty: keys2.length === 1 && Object.keys(base).length === 0 };
  };
  process = (recipeName, options) => {
    const { styles: variants } = options;
    const recipe = this.getRecipe(recipeName);
    if (!recipe)
      return;
    const slots = sharedState.slots.get(recipeName);
    if (slots) {
      slots.forEach((slotRecipe, slotKey) => {
        const { isEmpty, styles } = this.check(slotRecipe, slotKey, variants);
        if (isEmpty)
          return;
        const rule = this.rules.get(slotKey);
        if (!rule)
          return;
        const normalizedStyles = rule?.normalize(styles, false);
        rule.process({ styles: normalizedStyles });
      });
    } else {
      const { isEmpty, styles } = this.check(recipe.config, recipe.config.className, variants);
      if (isEmpty)
        return;
      const rule = this.rules.get(recipeName);
      if (!rule)
        return;
      const normalizedStyles = rule.normalize(styles, false);
      rule.process({ styles: normalizedStyles });
    }
  };
  filterDetails = (filters) => {
    const recipeDiffs = filters?.affecteds?.recipes;
    return recipeDiffs ? this.details.filter((recipe) => recipeDiffs.includes(recipe.dashName)) : this.details;
  };
};

// src/selector.ts
var import_postcss_selector_parser = __toESM(require("postcss-selector-parser"));
var import_ts_pattern2 = require("ts-pattern");
var parentNestingRegex = /\s&/g;
function extractParentSelectors(selector) {
  const result = /* @__PURE__ */ new Set();
  (0, import_postcss_selector_parser.default)((selectors) => {
    selectors.each((selector2) => {
      const condition = parseCondition(selector2.toString());
      (0, import_ts_pattern2.match)(condition).with({ type: "parent-nesting" }, () => {
        result.add(selector2.toString().replace(parentNestingRegex, "").trim());
      }).otherwise(() => {
      });
    });
  }).processSync(selector);
  const finalized = Array.from(result).join(", ").trim();
  return result.size > 1 ? `:where(${finalized})` : finalized;
}

// src/shared-hooks.ts
var import_hookable = require("hookable");
var sharedHooks = (0, import_hookable.createHooks)();

// src/static-css.ts
var formatCondition = (ctx, value) => ctx.breakpoints.includes(value) ? value : `_${value}`;
function getStaticCss(options) {
  const { css = [], recipes = {} } = options;
  const results = { css: [], recipes: [] };
  return (ctx) => {
    css.forEach((rule) => {
      const conditions = rule.conditions || [];
      if (rule.responsive) {
        conditions.push(...ctx.breakpoints);
      }
      Object.entries(rule.properties).forEach(([property, values]) => {
        const computedValues = values.flatMap((value) => value === "*" ? ctx.getPropertyKeys(property) : value);
        computedValues.forEach((value) => {
          const conditionalValues = conditions.reduce(
            (acc, condition) => ({
              base: value,
              ...acc,
              [formatCondition(ctx, condition)]: value
            }),
            {}
          );
          results.css.push({
            [property]: conditions.length ? conditionalValues : value
          });
        });
      });
    });
    Object.entries(recipes).forEach(([recipe, rules]) => {
      rules.forEach((rule) => {
        const { __base, ...recipeKeys } = ctx.getRecipeKeys(recipe);
        const useAllKeys = rule === "*";
        const { conditions = [], responsive = useAllKeys, ...variants } = useAllKeys ? recipeKeys : rule;
        if (responsive) {
          conditions.push(...ctx.breakpoints);
        }
        if (__base) {
          const conditionalValues = conditions.reduce(
            (acc, condition) => ({
              base: __base,
              ...acc,
              [formatCondition(ctx, condition)]: __base
            }),
            {}
          );
          results.recipes.push({
            [recipe]: conditions.length ? conditionalValues : __base
          });
        }
        Object.entries(variants).forEach(([variant, values]) => {
          if (!Array.isArray(values))
            return;
          const computedValues = values.flatMap((value) => {
            if (value === "*") {
              return recipeKeys[variant];
            }
            return value;
          });
          computedValues.forEach((value) => {
            const conditionalValues = conditions.reduce(
              (acc, condition) => ({
                base: value,
                ...acc,
                [formatCondition(ctx, condition)]: value
              }),
              {}
            );
            results.recipes.push({
              [recipe]: {
                [variant]: conditions.length ? conditionalValues : value
              }
            });
          });
        });
      });
    });
    return results;
  };
}

// src/stylesheet.ts
var import_logger2 = require("@pandacss/logger");
var import_shared11 = require("@pandacss/shared");
var import_postcss10 = require("postcss");
var Stylesheet = class {
  constructor(context) {
    this.context = context;
  }
  content = "";
  processGlobalCss = (styleObject) => {
    const { conditions, utility } = this.context;
    const css = serializeStyles(styleObject, { conditions, utility });
    this.context.layers.base.append(css);
  };
  processObject(styleObject) {
    const result = toCss(styleObject);
    const output = result.root;
    this.context.layers.root.append(output);
  }
  processAtomic = (...styleObject) => {
    const layers = this.context.layers;
    const ruleset = new AtomicRule(this.context, ({ layer, rule }) => {
      if (layer === "composition") {
        layers.utilities.compositions.append(rule);
      } else if (typeof layer === "string") {
        layers.utilities.custom(layer).append(rule);
      } else {
        layers.utilities.root.append(rule);
      }
    });
    styleObject.forEach((styles) => {
      if (!styles)
        return;
      const normalizedStyles = ruleset.normalize(styles);
      ruleset.process({ styles: normalizedStyles });
    });
  };
  processStyleProps = (styleObject) => {
    const { css: cssObject, ...restStyles } = styleObject;
    this.processAtomic(restStyles, cssObject);
  };
  processCompoundVariants = (config) => {
    config.compoundVariants?.forEach((compoundVariant) => {
      if (isSlotRecipe(config)) {
        for (const css of Object.values(compoundVariant.css)) {
          this.processAtomic(css);
        }
      } else {
        this.processAtomic(compoundVariant.css);
      }
    });
  };
  processRecipe = (name, config, styles) => {
    this.context.recipes.process(name, { styles });
    this.processCompoundVariants(config);
  };
  processAtomicSlotRecipe = (recipe) => {
    const slots = (0, import_shared11.getSlotRecipes)(recipe);
    for (const slotRecipe of Object.values(slots)) {
      this.processAtomicRecipe(slotRecipe);
    }
  };
  processAtomicRecipe = (recipe) => {
    const { base = {}, variants = {}, compoundVariants = [] } = recipe;
    this.processAtomic(base);
    for (const variant of Object.values(variants)) {
      for (const styles of Object.values(variant)) {
        this.processAtomic(styles);
      }
    }
    compoundVariants.forEach((compoundVariant) => {
      this.processAtomic(compoundVariant.css);
    });
  };
  getLayerCss = (...layers) => {
    return optimizeCss(
      layers.map((layer) => {
        return this.context.layers.getLayer(layer).toString();
      }).join("\n")
    );
  };
  toCss = ({ optimize = false, minify } = {}) => {
    try {
      const {
        conditions: { breakpoints },
        utility
      } = this.context;
      const root = this.context.layers.insert();
      breakpoints.expandScreenAtRule(root);
      expandCssFunctions(root, { token: utility.getToken, raw: this.context.utility.tokens.getByName });
      let css = root.toString();
      if (optimize) {
        css = optimizeCss(css, { minify });
      }
      if (this.content) {
        css = `${this.content}

${css}`;
      }
      return optimize ? optimizeCss(css, { minify }) : css;
    } catch (error) {
      if (error instanceof import_postcss10.CssSyntaxError) {
        import_logger2.logger.error("sheet", error.message);
        error.plugin && import_logger2.logger.error("sheet", `By plugin: ${error.plugin}:`);
        if (error.source) {
          import_logger2.logger.error("sheet", `Line ${error.line}:${error.column}, in:`);
          import_logger2.logger.error("sheet", error.source);
        }
      }
      throw error;
    }
  };
  append = (...css) => {
    this.context.layers.root.append(...css);
  };
  prepend = (...css) => {
    this.context.layers.root.prepend(...css);
  };
  clean = () => {
    this.context.layers.clean();
  };
};

// src/utility.ts
var import_shared12 = require("@pandacss/shared");
var Utility = class {
  /**
   * The token map or dictionary of tokens
   */
  tokens;
  /**
   * The map of property names to their resolved class names
   */
  classNames = /* @__PURE__ */ new Map();
  /**
   * The map of the property to their resolved styless
   */
  styles = /* @__PURE__ */ new Map();
  /**
   * Map of shorthand properties to their longhand properties
   */
  shorthands = /* @__PURE__ */ new Map();
  /**
   * The map of possible values for each property
   */
  types = /* @__PURE__ */ new Map();
  /**
   * The map of the property keys
   */
  propertyKeys = /* @__PURE__ */ new Map();
  /**
   * The utility config
   */
  config = {};
  /**
   * Useful for reporting custom values
   */
  customValues = /* @__PURE__ */ new Map();
  /**
   * The map of property names to their transform functions
   */
  transforms = /* @__PURE__ */ new Map();
  /**
   * The map of property names to their config
   */
  configs = /* @__PURE__ */ new Map();
  separator = "_";
  prefix = "";
  strictTokens = false;
  constructor(options) {
    const { tokens, config = {}, separator, prefix, shorthands, strictTokens } = options;
    this.tokens = tokens;
    this.config = config;
    if (separator) {
      this.separator = separator;
    }
    if (prefix) {
      this.prefix = prefix;
    }
    if (strictTokens) {
      this.strictTokens = strictTokens;
    }
    if (shorthands) {
      this.assignShorthands();
    }
    this.assignColorPaletteProperty();
    this.assignProperties();
    this.assignPropertyTypes();
  }
  register = (property, config) => {
    this.assignProperty(property, config);
    this.assignPropertyType(property, config);
    this.config[property] = config;
  };
  assignShorthands = () => {
    for (const [property, config] of Object.entries(this.config)) {
      const { shorthand } = this.normalize(config) ?? {};
      if (!shorthand)
        continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((shorthandName) => {
        this.shorthands.set(shorthandName, property);
      });
    }
  };
  assignColorPaletteProperty = () => {
    const values = this.tokens.colorPalettes;
    this.config.colorPalette = {
      values: Object.keys(values),
      transform(value) {
        return values[value];
      }
    };
  };
  resolveShorthand = (prop) => {
    return this.shorthands.get(prop) ?? prop;
  };
  get hasShorthand() {
    return this.shorthands.size > 0;
  }
  get isEmpty() {
    return Object.keys(this.config).length === 0;
  }
  entries = () => {
    const value = Object.entries(this.config).filter(([, value2]) => !!value2?.className).map(([key, value2]) => [key, value2.className]);
    return value;
  };
  getPropKey = (prop, value) => {
    return `(${prop} = ${value})`;
  };
  hash = (prop, value) => {
    return `${prop}${this.separator}${value}`;
  };
  /**
   * Get all the possible values for the defined property
   */
  getPropertyValues = (config, resolveFn) => {
    const { values } = config;
    const fn = (key) => {
      const value = resolveFn?.(key);
      return value ? { [value]: value } : void 0;
    };
    if ((0, import_shared12.isString)(values)) {
      return fn?.(values) ?? this.tokens.getValue(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if ((0, import_shared12.isFunction)(values)) {
      return values(resolveFn ? fn : this.getToken.bind(this));
    }
    return values;
  };
  getToken = (path) => {
    return this.tokens.get(path);
  };
  /**
   * Normalize the property config
   */
  normalize = (value) => {
    return value;
  };
  assignProperty = (property, propertyConfig) => {
    const config = this.normalize(propertyConfig);
    this.setTransform(property, config?.transform);
    if (!config)
      return;
    this.configs.set(property, config);
    const values = this.getPropertyValues(config);
    if (!values)
      return;
    for (const [alias, raw] of Object.entries(values)) {
      const propKey = this.getPropKey(property, alias);
      this.setStyles(property, raw, alias, propKey);
      this.setClassName(property, alias);
    }
  };
  assignProperties = () => {
    for (const [property, propertyConfig] of Object.entries(this.config)) {
      if (!propertyConfig)
        continue;
      this.assignProperty(property, propertyConfig);
    }
  };
  getPropertyKeys = (property) => {
    const keys2 = this.propertyKeys.get(property);
    return keys2 ? Array.from(keys2) : [];
  };
  assignPropertyType = (property, propertyConfig) => {
    const config = this.normalize(propertyConfig);
    if (!config)
      return;
    const values = this.getPropertyValues(config, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      this.types.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      this.types.set(property, keys2);
      this.propertyKeys.set(property, keys2);
    }
    const set = this.types.get(property) ?? /* @__PURE__ */ new Set();
    if (!this.strictTokens && config.property) {
      this.types.set(property, set.add(`CssProperties["${config.property}"]`));
    }
  };
  assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(this.config)) {
      if (!propertyConfig)
        continue;
      this.assignPropertyType(property, propertyConfig);
    }
  };
  /**
   * Returns the Typescript type for the define properties
   */
  getTypes = () => {
    const map = /* @__PURE__ */ new Map();
    for (const [prop, tokens] of this.types.entries()) {
      if (tokens.size === 0) {
        map.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(tokens).map((key) => {
        if (key.startsWith("CssProperties"))
          return key;
        if (key.startsWith("type:"))
          return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map.set(prop, typeValues);
    }
    return map;
  };
  defaultTransform = (0, import_shared12.memo)((value, prop) => {
    const isCssVar = prop.startsWith("--");
    if (isCssVar) {
      const tokenValue = this.tokens.getTokenVar(value);
      value = typeof tokenValue === "string" ? tokenValue : value;
    }
    return { [prop]: value };
  });
  setTransform = (property, transform) => {
    const defaultTransform = (value) => this.defaultTransform(value, property);
    const transformFn = transform ?? defaultTransform;
    this.transforms.set(property, transformFn);
    return this;
  };
  setStyles = (property, raw, alias, propKey) => {
    propKey = propKey ?? this.getPropKey(property, raw);
    const defaultTransform = (value) => this.defaultTransform(value, property);
    const getStyles = this.transforms.get(property) ?? defaultTransform;
    const tokenFn = Object.assign(this.getToken.bind(this), {
      raw: (path) => this.tokens.getByName(path)
    });
    const styles = getStyles(raw, { token: tokenFn, raw: alias });
    this.styles.set(propKey, styles ?? {});
    return this;
  };
  formatClassName = (className) => {
    return [this.prefix, className].filter(Boolean).join("-");
  };
  setClassName = (property, raw) => {
    const propKey = this.getPropKey(property, raw);
    const config = this.configs.get(property);
    let className;
    if (!config || !config.className) {
      className = this.hash((0, import_shared12.hypenateProperty)(property), raw);
    } else {
      className = this.hash(config.className, raw);
    }
    this.classNames.set(propKey, className);
    return this;
  };
  /**
   * Whether a given property exists in the config
   */
  isProperty = (prop) => {
    return this.configs.has(prop);
  };
  /**
   * Returns the resolved className for a given property and value
   */
  getOrCreateClassName = (prop, value) => {
    const inner = (prop2, value2) => {
      const propKey = this.getPropKey(prop2, value2);
      if (!this.classNames.has(propKey)) {
        if (this.isProperty(prop2)) {
          this.customValues.set(prop2, value2);
        }
        this.setClassName(prop2, value2);
      }
      return this.classNames.get(propKey);
    };
    return inner(prop, value);
  };
  /**
   * Get or create the resolved styles for a given property and value
   */
  getOrCreateStyle = (prop, value) => {
    const propKey = this.getPropKey(prop, value);
    this.styles.get(propKey) ?? this.setStyles(prop, value, value, propKey);
    return this.styles.get(propKey);
  };
  /**
   * Returns the resolved className and styles for a given property and value
   */
  transform = (prop, value) => {
    if (value == null) {
      return { className: "", styles: {} };
    }
    const key = this.resolveShorthand(prop);
    return (0, import_shared12.compact)({
      layer: this.configs.get(key)?.layer,
      className: this.getOrCreateClassName(key, (0, import_shared12.withoutSpace)(value)),
      styles: this.getOrCreateStyle(key, (0, import_shared12.getArbitraryValue)(value))
    });
  };
  /**
   * All keys including shorthand keys
   */
  keys = () => {
    const shorthands = Array.from(this.shorthands.keys());
    const properties = Object.keys(this.config);
    return [...shorthands, ...properties];
  };
  /**
   * Returns a map of the property keys and their shorthands
   */
  getPropShorthandsMap = () => {
    const shorthandsByProp = /* @__PURE__ */ new Map();
    this.shorthands.forEach((prop, shorthand) => {
      const list = shorthandsByProp.get(prop) ?? [];
      list.push(shorthand);
      shorthandsByProp.set(prop, list);
    });
    return shorthandsByProp;
  };
  /**
   * Returns the shorthands for a given property
   */
  getPropShorthands = (prop) => {
    return this.getPropShorthandsMap().get(prop) ?? [];
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AtomicRule,
  Breakpoints,
  Conditions,
  Layers,
  Recipes,
  Stylesheet,
  Utility,
  assignCompositions,
  expandCssFunctions,
  expandNestedCss,
  extractParentSelectors,
  getStaticCss,
  isSlotRecipe,
  optimizeCss,
  prettifyCss,
  sharedHooks,
  toCss,
  toKeyframeCss
});
