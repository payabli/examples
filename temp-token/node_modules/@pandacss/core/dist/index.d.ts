import * as _pandacss_types from '@pandacss/types';
import { RawCondition, Dict, CascadeLayers, CascadeLayer, RecipeConfig, SlotRecipeConfig, ArtifactFilters, UtilityConfig, PropertyConfig, PatternHelpers, CssKeyframes, Token, StaticCssOptions, SystemStyleObject } from '@pandacss/types';
import postcss, { Root, Container, ChildNode, AtRule } from 'postcss';
import { TokenDictionary } from '@pandacss/token-dictionary';
import * as hookable from 'hookable';

declare class Breakpoints {
    private breakpoints;
    constructor(breakpoints: Record<string, string>);
    get sorted(): Entries;
    get values(): {
        [k: string]: {
            name: string;
            min?: string | null | undefined;
            max?: string | null | undefined;
        };
    };
    get keys(): string[];
    get: (name: string) => {
        name: string;
        min?: string | null | undefined;
        max?: string | null | undefined;
    };
    build: ({ min, max }: {
        min?: string | null | undefined;
        max?: string | null | undefined;
    }) => string;
    only: (name: string) => string;
    get ranges(): Record<string, string>;
    get conditions(): Record<string, Cond>;
    getCondition: (key: string) => Cond | undefined;
    expandScreenAtRule: (root: Root) => void;
}
type Entries = [string, {
    name: string;
    min?: string | null;
    max?: string | null;
}][];
type Cond = RawCondition & {
    params: string;
};

declare class ConditionalRule {
    private conditionsMap;
    rule: Container | undefined;
    selector: string;
    nodes: ChildNode[];
    constructor(conditionsMap: StylesheetContext['conditions']);
    get isEmpty(): boolean;
    update: () => void;
    applyConditions: (conditions: string[]) => void;
    toString(): string;
}

interface Options {
    conditions?: Dict<string>;
    breakpoints?: Record<string, string>;
}
declare class Conditions {
    private options;
    values: Record<string, RawCondition>;
    breakpoints: Breakpoints;
    constructor(options: Options);
    finalize: (paths: string[]) => string[];
    shift: (paths: string[]) => string[];
    segment: (paths: string[]) => {
        condition: string[];
        selector: string[];
    };
    has: (key: string) => boolean;
    isCondition: (key: string) => boolean;
    isEmpty: () => boolean;
    get: (key: string) => string;
    getRaw: (condition: string) => RawCondition | undefined;
    sort: (conditions: string[]) => RawCondition[];
    normalize: (condition: string | RawCondition) => RawCondition | undefined;
    keys: () => string[];
    rule: () => ConditionalRule;
    saveOne: (key: string, value: string) => void;
    remove(key: string): void;
}

declare class Layers {
    private names;
    root: Root;
    reset: AtRule;
    base: AtRule;
    tokens: AtRule;
    recipes: {
        root: AtRule;
        base: AtRule;
    };
    slotRecipes: {
        root: AtRule;
        base: AtRule;
    };
    utilities: {
        root: AtRule;
        compositions: AtRule;
        custom(layer: string): AtRule;
    };
    private utilityRuleMap;
    constructor(names: CascadeLayers);
    getLayer(layer: CascadeLayer): postcss.AtRule | postcss.Root;
    insert(): postcss.Root;
    clean(): void;
    get layerNames(): string[];
    isValidParams(params: string): boolean;
    get params(): string;
}

interface RecipeRecord {
    [key: string]: RecipeConfig | SlotRecipeConfig;
}
declare class Recipes {
    private recipes;
    private context;
    /**
     * The map of the recipes to their atomic rules
     */
    rules: Map<string, AtomicRule>;
    get keys(): string[];
    constructor(recipes: RecipeRecord, context: RecipeContext);
    private getPropKey;
    private get separator();
    private getClassName;
    prune: () => void;
    save: () => void;
    saveOne: (name: string, recipe: RecipeConfig | SlotRecipeConfig) => void;
    remove(name: string): void;
    private assignRecipe;
    getSlotKey: (name: string, slot: string) => string;
    isEmpty: () => boolean;
    getNames: (name: string) => {
        baseName: string;
        upperName: string;
        dashName: string;
        jsxName: string;
    };
    getRecipe: (name: string) => RecipeNode | undefined;
    getConfig: (name: string) => RecipeConfig<_pandacss_types.RecipeVariantRecord> | SlotRecipeConfig;
    find: (jsxName: string) => RecipeNode | undefined;
    filter: (jsxName: string) => RecipeNode[];
    get details(): RecipeNode[];
    splitProps: (recipeName: string, props: Dict) => Dict[];
    normalize: (name: string, config: RecipeConfig) => Required<RecipeConfig<_pandacss_types.RecipeVariantRecord>>;
    private serialize;
    private getTransform;
    private createRule;
    private check;
    process: (recipeName: string, options: ProcessOptions) => void;
    filterDetails: (filters?: ArtifactFilters) => RecipeNode[];
}

interface UtilityOptions {
    config?: UtilityConfig;
    tokens: TokenDictionary;
    separator?: string;
    prefix?: string;
    shorthands?: boolean;
    strictTokens?: boolean;
}
declare class Utility {
    /**
     * The token map or dictionary of tokens
     */
    tokens: TokenDictionary;
    /**
     * The map of property names to their resolved class names
     */
    classNames: Map<string, string>;
    /**
     * The map of the property to their resolved styless
     */
    styles: Map<string, Dict>;
    /**
     * Map of shorthand properties to their longhand properties
     */
    shorthands: Map<string, string>;
    /**
     * The map of possible values for each property
     */
    types: Map<string, Set<string>>;
    /**
     * The map of the property keys
     */
    propertyKeys: Map<string, Set<string>>;
    /**
     * The utility config
     */
    config: UtilityConfig;
    /**
     * Useful for reporting custom values
     */
    customValues: Map<string, string>;
    /**
     * The map of property names to their transform functions
     */
    private transforms;
    /**
     * The map of property names to their config
     */
    private configs;
    separator: string;
    prefix: string;
    strictTokens: boolean;
    constructor(options: UtilityOptions);
    register: (property: string, config: PropertyConfig) => void;
    private assignShorthands;
    private assignColorPaletteProperty;
    resolveShorthand: (prop: string) => string;
    get hasShorthand(): boolean;
    get isEmpty(): boolean;
    entries: () => [string, string][];
    private getPropKey;
    private hash;
    /**
     * Get all the possible values for the defined property
     */
    getPropertyValues: (config: PropertyConfig, resolveFn?: ((key: string) => string) | undefined) => Record<string, string> | {
        type: string;
    } | undefined;
    getToken: (path: string) => string;
    /**
     * Normalize the property config
     */
    normalize: (value: PropertyConfig | undefined) => PropertyConfig | undefined;
    private assignProperty;
    private assignProperties;
    getPropertyKeys: (property: string) => string[];
    private assignPropertyType;
    private assignPropertyTypes;
    /**
     * Returns the Typescript type for the define properties
     */
    getTypes: () => Map<string, string[]>;
    defaultTransform: (value: string, prop: string) => {
        [x: string]: string;
    };
    private setTransform;
    private setStyles;
    formatClassName: (className: string) => string;
    private setClassName;
    /**
     * Whether a given property exists in the config
     */
    private isProperty;
    /**
     * Returns the resolved className for a given property and value
     */
    private getOrCreateClassName;
    /**
     * Get or create the resolved styles for a given property and value
     */
    private getOrCreateStyle;
    /**
     * Returns the resolved className and styles for a given property and value
     */
    transform: (prop: string, value: string | undefined) => TransformResult;
    /**
     * All keys including shorthand keys
     */
    keys: () => string[];
    /**
     * Returns a map of the property keys and their shorthands
     */
    getPropShorthandsMap: () => Map<string, string[]>;
    /**
     * Returns the shorthands for a given property
     */
    getPropShorthands: (prop: string) => string[];
}

type RecipeContext = Pick<StylesheetContext, 'utility' | 'conditions' | 'layers'>;
type AtomicRuleContext = Pick<StylesheetContext, 'conditions' | 'hash' | 'utility' | 'transform' | 'layers'>;
interface TransformResult {
    layer?: string;
    className: string;
    styles: Dict;
}
type AtomicRuleTransform = (prop: string, value: any) => TransformResult;
interface StylesheetContext {
    layers: Layers;
    utility: Utility;
    conditions: Conditions;
    recipes: Recipes;
    helpers: PatternHelpers;
    hash?: boolean;
    transform?: AtomicRuleTransform;
}
interface RecipeNode {
    /**
     * The name of the recipe
     */
    baseName: string;
    /**
     * Discriminant
     */
    type: 'recipe';
    /**
     * The keys of the variants
     */
    variantKeys: string[];
    /**
     * The map of the variant keys to their possible values
     */
    variantKeyMap: Record<string, string[]>;
    /**
     * The jsx keys or regex to match the recipe
     */
    jsx: (string | RegExp)[];
    /**
     * The name of the recipe in upper case
     */
    upperName: string;
    /**
     * The name of the recipe in dash case
     */
    dashName: string;
    /**
     * The name of the recipe in camel case
     */
    jsxName: string;
    /**
     * The regex to match the recipe
     */
    match: RegExp;
    /**
     * The transformed recipe config
     */
    config: RecipeConfig | SlotRecipeConfig;
    /**
     * The function to split the props
     */
    splitProps: (props: Dict) => [Dict, Dict];
    /**
     * The props of the recipe
     */
    props: string[];
}

interface ProcessOptions {
    styles: Dict;
}
interface WriteOptions {
    layer: string | undefined;
    rule: Container;
}
declare class AtomicRule {
    private context;
    private fn;
    constructor(context: AtomicRuleContext, fn: (opts: WriteOptions) => void);
    hashFn: (conditions: string[], className: string) => string;
    get rule(): ConditionalRule;
    get transform(): (prop: string, value: string | undefined) => TransformResult;
    normalize: (styles: Dict, normalizeShorthand?: boolean) => Dict;
    process: (options: ProcessOptions) => void;
}

interface SerializeContext {
    conditions: Conditions;
    utility: Utility;
}

declare function assignCompositions(compositions: Dict, ctx: SerializeContext): void;

declare const isSlotRecipe: (v: RecipeConfig | SlotRecipeConfig) => v is SlotRecipeConfig;

declare function toKeyframeCss(values: CssKeyframes): string;

interface OptimizeOptions {
    minify?: boolean;
}
declare function optimizeCss(code: string | Container, options?: OptimizeOptions): string;
declare function expandCssFunctions(code: string | Root, options?: {
    token?: (key: string) => string;
    raw?: (path: string) => Token | undefined;
}): string;
declare function expandNestedCss(code: string): string;
declare function prettifyCss(code: string): string;

declare function extractParentSelectors(selector: string): string;

declare const sharedHooks: hookable.Hookable<Record<string, any>, string>;

interface StaticContext {
    breakpoints: string[];
    getPropertyKeys: (property: string) => string[];
    getRecipeKeys: (recipe: string) => {
        [variant: string]: string[];
    };
}
declare function getStaticCss(options: StaticCssOptions): (ctx: StaticContext) => {
    css: Record<string, any>[];
    recipes: Record<string, any>[];
};

declare class Stylesheet {
    private context;
    content: string;
    constructor(context: StylesheetContext);
    processGlobalCss: (styleObject: Dict) => void;
    processObject(styleObject: SystemStyleObject): void;
    processAtomic: (...styleObject: (SystemStyleObject | undefined)[]) => void;
    processStyleProps: (styleObject: SystemStyleObject & {
        css?: SystemStyleObject;
    }) => void;
    processCompoundVariants: (config: RecipeConfig | SlotRecipeConfig) => void;
    processRecipe: (name: string, config: RecipeConfig | SlotRecipeConfig, styles: SystemStyleObject) => void;
    processAtomicSlotRecipe: (recipe: Pick<SlotRecipeConfig, 'base' | 'variants' | 'compoundVariants'>) => void;
    processAtomicRecipe: (recipe: Pick<RecipeConfig, 'base' | 'variants' | 'compoundVariants'>) => void;
    getLayerCss: (...layers: CascadeLayer[]) => string;
    toCss: ({ optimize, minify }?: {
        optimize?: boolean | undefined;
        minify?: boolean | undefined;
    }) => string;
    append: (...css: string[]) => void;
    prepend: (...css: string[]) => void;
    clean: () => void;
}

declare function toCss(styles: Dict, { important }?: {
    important?: boolean;
}): postcss.LazyResult<postcss.Document | postcss.Root>;

export { AtomicRule, AtomicRuleContext, Breakpoints, Conditions, Layers, RecipeContext, RecipeNode, Recipes, Stylesheet, StylesheetContext, TransformResult, Utility, assignCompositions, expandCssFunctions, expandNestedCss, extractParentSelectors, getStaticCss, isSlotRecipe, optimizeCss, prettifyCss, sharedHooks, toCss, toKeyframeCss };
