declare const isString: (v: any) => v is string;
type AnyFunction = (...args: any[]) => any;
declare const isFunction: (v: any) => v is AnyFunction;
declare function isObject(value: any): value is Record<string, any>;

interface CreateCssContext {
    hash?: boolean;
    /**
     * Partial properties from the Utility class
     */
    utility: {
        prefix: string;
        hasShorthand: boolean;
        resolveShorthand: (prop: string) => string;
        transform: (prop: string, value: any) => {
            className: string;
        };
    };
    /**
     * Partial properties from the Condition class
     */
    conditions?: {
        breakpoints: {
            keys: string[];
        };
        shift: (paths: string[]) => string[];
        finalize: (paths: string[]) => string[];
    };
}
declare function createCss(context: CreateCssContext): (styleObject?: Record<string, any>) => string;
interface StyleObject {
    [key: string]: any;
}
declare function createMergeCss(context: CreateCssContext): {
    mergeCss: (...styles: StyleObject[]) => StyleObject;
    assignCss: (...styles: StyleObject[]) => any;
};

declare function compact<T extends Record<string, any>>(value: T): T;

declare const isBaseCondition: (v: string) => boolean;
declare function filterBaseConditions(c: string[]): string[];

declare function isImportant(value: string): boolean;
declare function withoutImportant(value: string): string;
declare function withoutSpace(str: string): string;

type Predicate<R = any> = (value: any, path: string[]) => R;
type MappedObject<T, K> = {
    [Prop in keyof T]: T[Prop] extends Array<any> ? MappedObject<T[Prop][number], K>[] : T[Prop] extends Record<string, unknown> ? MappedObject<T[Prop], K> : K;
};
type WalkObjectStopFn = (value: any, path: string[]) => boolean;
interface WalkObjectOptions {
    stop?: WalkObjectStopFn;
    getKey?(prop: string): string;
}
declare function walkObject<T, K>(target: T, predicate: Predicate<K>, options?: WalkObjectOptions): MappedObject<T, ReturnType<Predicate<K>>>;
declare function mapObject(obj: any, fn: (value: any) => any): any;

declare function toHash(value: string): string;

declare const hypenateProperty: (property: string) => string;

declare const memo: <T extends (...args: any[]) => any>(fn: T) => T;

declare function mergeProps<T extends Record<string, unknown>>(...sources: T[]): T;

declare const getSlotRecipes: (recipe?: Record<string, any>) => Record<string, any>;
declare const getSlotCompoundVariant: <T extends {
    css: any;
}>(compoundVariants: T[], slotName: string) => (T & {
    css: any;
})[];

type Dict = Record<string, unknown>;
type PredicateFn = (key: string) => boolean;
type Key = PredicateFn | string[];
declare function splitProps(props: Dict, ...keys: Key[]): Dict[];

declare const uniq: <T>(...items: T[][]) => T[];

export { CreateCssContext as C, MappedObject as M, WalkObjectStopFn as W, isFunction as a, isObject as b, createCss as c, createMergeCss as d, compact as e, isBaseCondition as f, filterBaseConditions as g, isImportant as h, isString as i, withoutSpace as j, hypenateProperty as k, mergeProps as l, memo as m, getSlotRecipes as n, getSlotCompoundVariant as o, WalkObjectOptions as p, walkObject as q, mapObject as r, splitProps as s, toHash as t, uniq as u, withoutImportant as w };
