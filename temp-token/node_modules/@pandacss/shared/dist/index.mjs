// src/arbitrary-value.ts
var getArbitraryValue = (value) => {
  if (!value)
    return value;
  if (value[0] === "[" && value[value.length - 1] === "]") {
    return value.slice(1, -1);
  }
  return value;
};

// src/assert.ts
var isString = (v) => typeof v === "string";
var isFunction = (v) => typeof v === "function";
function isObject(value) {
  return typeof value === "object" && value != null && !Array.isArray(value);
}

// src/astish.ts
var newRule = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g;
var ruleClean = /\/\*[^]*?\*\/|  +/g;
var ruleNewline = /\n+/g;
var empty = " ";
var astish = (val, tree = [{}]) => {
  if (!val)
    return tree[0];
  let block, left;
  while (block = newRule.exec(val.replace(ruleClean, ""))) {
    if (block[4])
      tree.shift();
    else if (block[3]) {
      left = block[3].replace(ruleNewline, empty).trim();
      tree.unshift(tree[0][left] = tree[0][left] || {});
    } else
      tree[0][block[1]] = block[2].replace(ruleNewline, empty).trim();
  }
  return tree[0];
};

// src/calc.ts
function isCssVar(value) {
  return isObject(value) && "ref" in value;
}
function getRef(operand) {
  return isCssVar(operand) ? operand.ref : operand.toString();
}
var calcRegex = /calc/g;
var toExpression = (operator, ...operands) => operands.map(getRef).join(` ${operator} `).replace(calcRegex, "");
var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
var calc = {
  negate(x) {
    const value = getRef(x);
    if (value != null && !Number.isNaN(parseFloat(value))) {
      return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
    }
    return multiply(value, -1);
  }
};

// src/memo.ts
var memo = (fn) => {
  const cache = /* @__PURE__ */ new Map();
  const get = (...args) => {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
  return get;
};

// src/camelcase-property.ts
var regex = /-(\w|$)/g;
var callback = (_dashChar, char) => char.toUpperCase();
var camelCaseProperty = memo((property) => {
  if (property.startsWith("--"))
    return property;
  let str = property.toLowerCase();
  str = str.startsWith("-ms-") ? str.substring(1) : str;
  return str.replace(regex, callback);
});

// src/capitalize.ts
var capitalize = (s) => s.charAt(0).toUpperCase() + s.slice(1);
var camelCaseRegex = /([a-z])([A-Z])/g;
var dashCase = (s) => s.replace(camelCaseRegex, "$1-$2").toLowerCase();
var uncapitalize = (s) => s.charAt(0).toLowerCase() + s.slice(1);

// src/compact.ts
function compact(value) {
  return Object.fromEntries(Object.entries(value ?? {}).filter(([_, value2]) => value2 !== void 0));
}

// src/condition.ts
var isBaseCondition = (v) => v === "base";
function filterBaseConditions(c) {
  return c.slice().filter((v) => !isBaseCondition(v));
}

// src/css-important.ts
var importantRegex = /!(important)?/;
function isImportant(value) {
  return typeof value === "string" ? importantRegex.test(value) : false;
}
function withoutImportant(value) {
  return typeof value === "string" ? value.replace(importantRegex, "").trim() : value;
}
function withoutSpace(str) {
  return typeof str === "string" ? str.replaceAll(" ", "_") : str;
}

// src/hash.ts
function toChar(code) {
  return String.fromCharCode(code + (code > 25 ? 39 : 97));
}
function toName(code) {
  let name = "";
  let x;
  for (x = Math.abs(code); x > 52; x = x / 52 | 0)
    name = toChar(x % 52) + name;
  return toChar(x % 52) + name;
}
function toPhash(h, x) {
  let i = x.length;
  while (i)
    h = h * 33 ^ x.charCodeAt(--i);
  return h;
}
function toHash(value) {
  return toName(toPhash(5381, value) >>> 0);
}

// src/merge-props.ts
function mergeProps(...sources) {
  const objects = sources.filter(Boolean);
  return objects.reduce((prev, obj) => {
    Object.keys(obj).forEach((key) => {
      const prevValue = prev[key];
      const value = obj[key];
      if (isObject(prevValue) && isObject(value)) {
        prev[key] = mergeProps(prevValue, value);
      } else {
        prev[key] = value;
      }
    });
    return prev;
  }, {});
}

// src/walk-object.ts
var isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path = []) {
    if (isObject(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = getKey?.(prop) ?? prop;
        const childPath = [...path, key];
        if (stop?.(value, childPath)) {
          return predicate(value, path);
        }
        const next = inner(child, childPath);
        if (isNotNullish(next)) {
          result[key] = next;
        }
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  if (Array.isArray(obj))
    return obj.map((value) => fn(value));
  if (!isObject(obj))
    return fn(obj);
  return walkObject(obj, (value) => fn(value));
}

// src/normalize-style-object.ts
function toResponsiveObject(values, breakpoints) {
  return values.reduce((acc, current, index) => {
    const key = breakpoints[index];
    if (current != null) {
      acc[key] = current;
    }
    return acc;
  }, {});
}
function normalizeShorthand(styles, context) {
  const { hasShorthand, resolveShorthand } = context.utility;
  return walkObject(styles, (v) => v, {
    getKey: (prop) => {
      return hasShorthand ? resolveShorthand(prop) : prop;
    }
  });
}
function normalizeStyleObject(styles, context, shorthand = true) {
  const { utility, conditions } = context;
  const { hasShorthand, resolveShorthand } = utility;
  return walkObject(
    styles,
    (value) => {
      return Array.isArray(value) ? toResponsiveObject(value, conditions.breakpoints.keys) : value;
    },
    {
      stop: (value) => Array.isArray(value),
      getKey: shorthand ? (prop) => hasShorthand ? resolveShorthand(prop) : prop : void 0
    }
  );
}

// src/classname.ts
var fallbackCondition = {
  shift: (v) => v,
  finalize: (v) => v,
  breakpoints: { keys: [] }
};
var sanitize = (value) => typeof value === "string" ? value.replaceAll(/[\n\s]+/g, " ") : value;
function createCss(context) {
  const { utility, hash, conditions: conds = fallbackCondition } = context;
  const formatClassName = (str) => [utility.prefix, str].filter(Boolean).join("-");
  const hashFn = (conditions, className) => {
    let result;
    if (hash) {
      const baseArray = [...conds.finalize(conditions), className];
      result = formatClassName(toHash(baseArray.join(":")));
    } else {
      const baseArray = [...conds.finalize(conditions), formatClassName(className)];
      result = baseArray.join(":");
    }
    return result;
  };
  return (styleObject = {}) => {
    const normalizedObject = normalizeStyleObject(styleObject, context);
    const classNames = /* @__PURE__ */ new Set();
    walkObject(normalizedObject, (value, paths) => {
      const important = isImportant(value);
      if (value == null)
        return;
      const [prop, ...allConditions] = conds.shift(paths);
      const conditions = filterBaseConditions(allConditions);
      const transformed = utility.transform(prop, withoutImportant(sanitize(value)));
      let className = hashFn(conditions, transformed.className);
      if (important)
        className = `${className}!`;
      classNames.add(className);
    });
    return Array.from(classNames).join(" ");
  };
}
function compactStyles(...styles) {
  return styles.filter((style) => isObject(style) && Object.keys(compact(style)).length > 0);
}
function createMergeCss(context) {
  function resolve(styles) {
    const allStyles = compactStyles(...styles);
    if (allStyles.length === 1)
      return allStyles;
    return allStyles.map((style) => normalizeShorthand(style, context));
  }
  function mergeCss(...styles) {
    return mergeProps(...resolve(styles));
  }
  function assignCss(...styles) {
    return Object.assign({}, ...resolve(styles));
  }
  return { mergeCss, assignCss };
}

// src/css-unit.ts
var BASE_FONT_SIZE = 16;
var UNIT_PX = "px";
var UNIT_EM = "em";
var UNIT_REM = "rem";
function getUnit(value = "") {
  const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
  const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
  const unit = value.match(new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`));
  return unit?.[1];
}
function toPx(value = "") {
  if (typeof value === "number") {
    return `${value}px`;
  }
  const unit = getUnit(value);
  if (!unit)
    return value;
  if (unit === UNIT_PX) {
    return value;
  }
  if (unit === UNIT_EM || unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
  }
}
function toEm(value = "", fontSize = BASE_FONT_SIZE) {
  const unit = getUnit(value);
  if (!unit)
    return value;
  if (unit === UNIT_EM) {
    return value;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / fontSize}${UNIT_EM}`;
  }
  if (unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE / fontSize}${UNIT_EM}`;
  }
}
function toRem(value = "") {
  const unit = getUnit(value);
  if (!unit)
    return value;
  if (unit === UNIT_REM) {
    return value;
  }
  if (unit === UNIT_EM) {
    return `${parseFloat(value)}${UNIT_REM}`;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
  }
}

// src/css-var.ts
var escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
function esc(string) {
  return `${string}`.replace(escRegex, (s) => `\\${s}`);
}
var dashCaseRegex = /[A-Z]/g;
function dashCase2(string) {
  return string.replace(dashCaseRegex, (match) => `-${match.toLowerCase()}`);
}
function cssVar(name, options = {}) {
  const { fallback = "", prefix = "", hash } = options;
  const variable = hash ? ["-", prefix, toHash(name)].filter(Boolean).join("-") : dashCase2(["-", prefix, esc(name)].filter(Boolean).join("-"));
  const result = {
    var: variable,
    ref: `var(${variable}${fallback ? `, ${fallback}` : ""})`
  };
  return result;
}

// src/esc.ts
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
var fcssescape = function(ch, asCodePoint) {
  if (!asCodePoint)
    return "\\" + ch;
  if (ch === "\0")
    return "\uFFFD";
  if (ch === "-" && ch.length === 1)
    return "\\-";
  return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16);
};
var esc2 = (sel) => {
  return (sel + "").replace(rcssescape, fcssescape);
};

// src/flatten.ts
function flatten(values, stop) {
  const result = {};
  walkObject(
    values,
    (token, paths) => {
      if (token) {
        result[paths.join(".")] = token.value;
      }
    },
    {
      stop: stop ?? ((v) => {
        return isObject(v) && "value" in v;
      })
    }
  );
  return result;
}

// src/hypenate-property.ts
var wordRegex = /([A-Z])/g;
var msRegex = /^ms-/;
var hypenateProperty = memo((property) => {
  if (property.startsWith("--"))
    return property;
  return property.replace(wordRegex, "-$1").replace(msRegex, "-ms-").toLowerCase();
});

// src/regex.ts
var createRegex = (item) => {
  const regex2 = item.map((item2) => typeof item2 === "string" ? `^${item2}$` : item2.source).join("|");
  return new RegExp(regex2);
};

// src/serialize.ts
var stringifyJson = (config) => {
  return JSON.stringify(config, (_key, value) => {
    if (typeof value === "function")
      return value.toString();
    return value;
  });
};
var parseJson = (config) => {
  return JSON.parse(config);
};

// src/slot.ts
var getSlotRecipes = (recipe = {}) => {
  const init = (slot) => ({
    className: [recipe.className, slot].filter(Boolean).join("__"),
    base: recipe.base?.[slot] ?? {},
    variants: {},
    defaultVariants: recipe.defaultVariants ?? {},
    compoundVariants: recipe.compoundVariants ? getSlotCompoundVariant(recipe.compoundVariants, slot) : []
  });
  const slots = recipe.slots ?? [];
  const recipeParts = slots.map((slot) => [slot, init(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(recipe.variants ?? {})) {
    for (const [variantKey, variantSpec] of Object.entries(variantsSpec)) {
      recipeParts.forEach(([slot, slotRecipe]) => {
        slotRecipe.variants[variantsKey] ??= {};
        slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
    }
  }
  return Object.fromEntries(recipeParts);
};
var getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({ ...compoundVariant, css: compoundVariant.css[slotName] }));

// src/split.ts
function splitBy(value, separator = ",") {
  const result = [];
  let current = "";
  let depth = 0;
  for (let i = 0; i < value.length; i++) {
    const char = value[i];
    if (char === "(") {
      depth++;
    } else if (char === ")") {
      depth--;
    } else if (char === separator && depth === 0) {
      result.push(current);
      current = "";
      continue;
    }
    current += char;
  }
  result.push(current);
  return result;
}
function splitDotPath(path) {
  return path.split(".").reduce((acc, curr) => {
    const last = acc[acc.length - 1];
    if (last != null && !isNaN(Number(last)) && !isNaN(Number(curr))) {
      acc[acc.length - 1] = `${last}.${curr}`;
    } else {
      acc.push(curr);
    }
    return acc;
  }, []);
}
function getNegativePath(path) {
  return path.slice(0, -1).concat(`-${path.at(-1)}`);
}
function getDotPath(obj, path, fallback) {
  if (typeof path !== "string")
    return fallback;
  const idx = path.indexOf(".");
  if (idx === -1) {
    return obj?.[path] ?? fallback;
  }
  const key = path.slice(0, idx);
  const nextPath = path.slice(idx + 1);
  const checkValue = obj?.[key]?.[nextPath];
  if (checkValue) {
    return checkValue;
  }
  return getDotPath(obj?.[key], nextPath, fallback) ?? fallback;
}

// src/split-props.ts
function splitProps(props, ...keys) {
  const descriptors = Object.getOwnPropertyDescriptors(props);
  const dKeys = Object.keys(descriptors);
  const split = (k) => {
    const clone = {};
    for (let i = 0; i < k.length; i++) {
      const key = k[i];
      if (descriptors[key]) {
        Object.defineProperty(clone, key, descriptors[key]);
        delete descriptors[key];
      }
    }
    return clone;
  };
  const fn = (key) => split(Array.isArray(key) ? key : dKeys.filter(key));
  return keys.map(fn).concat(split(dKeys));
}

// src/to-json.ts
function mapToJson(map) {
  const obj = {};
  map.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}

// src/typegen.ts
function unionType(values) {
  return Array.from(values).map((value) => JSON.stringify(value)).join(" | ");
}

// src/uniq.ts
var uniq = (...items) => items.filter(Boolean).reduce((acc, item) => Array.from(/* @__PURE__ */ new Set([...acc, ...item])), []);
export {
  astish,
  calc,
  camelCaseProperty,
  capitalize,
  compact,
  createCss,
  createMergeCss,
  createRegex,
  cssVar,
  dashCase,
  esc2 as esc,
  filterBaseConditions,
  flatten,
  getArbitraryValue,
  getDotPath,
  getNegativePath,
  getSlotCompoundVariant,
  getSlotRecipes,
  getUnit,
  hypenateProperty,
  isBaseCondition,
  isFunction,
  isImportant,
  isObject,
  isString,
  mapObject,
  mapToJson,
  memo,
  mergeProps,
  normalizeShorthand,
  normalizeStyleObject,
  parseJson,
  splitBy,
  splitDotPath,
  splitProps,
  stringifyJson,
  toEm,
  toHash,
  toPx,
  toRem,
  uncapitalize,
  unionType,
  uniq,
  walkObject,
  withoutImportant,
  withoutSpace
};
