"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/cli-main.ts
var cli_main_exports = {};
__export(cli_main_exports, {
  main: () => main
});
module.exports = __toCommonJS(cli_main_exports);
var import_config = require("@pandacss/config");
var import_logger = require("@pandacss/logger");
var import_node = require("@pandacss/node");
var import_shared = require("@pandacss/shared");
var import_cac = require("cac");
var import_pathe = require("pathe");
var import_perfect_debounce = require("perfect-debounce");

// package.json
var version = "0.22.1";

// src/interactive.ts
var p = __toESM(require("@clack/prompts"));
var interactive = async () => {
  p.intro(`panda v${version}`);
  const initFlags = await p.group(
    {
      usePostcss: () => p.select({
        message: "Would you like to use PostCSS ?",
        initialValue: "yes",
        options: [
          { value: "yes", label: "Yes" },
          { value: "no", label: "No" }
        ]
      }),
      useMjsExtension: () => p.select({
        message: "Use the mjs extension ?",
        initialValue: "yes",
        options: [
          { value: "yes", label: "Yes" },
          { value: "no", label: "No" }
        ]
      }),
      jsxOptions: () => p.group({
        styleProps: () => p.select({
          message: "Would you like to use JSX Style Props ?",
          initialValue: "yes",
          options: [
            { value: "yes", label: "Yes" },
            { value: "no", label: "No" }
          ]
        }),
        jsxFramework: () => p.select({
          message: "What JSX framework?",
          initialValue: "react",
          options: [
            { value: "react", label: "React" },
            { value: "vue", label: "Vue" },
            { value: "solid", label: "Solid" },
            { value: "qwik", label: "Qwik" }
          ]
        })
      }),
      whatSyntax: () => p.select({
        message: "What css syntax would you like to use?",
        initialValue: "object",
        options: [
          { value: "object-literal", label: "Object" },
          { value: "template-literal", label: "Template literal" }
        ]
      }),
      withStrictTokens: () => p.select({
        message: "Use strict tokens to enforce full type-safety?",
        initialValue: "no",
        options: [
          { value: "yes", label: "Yes" },
          { value: "no", label: "No" }
        ]
      }),
      shouldUpdateGitignore: () => p.select({
        message: "Update gitignore?",
        initialValue: "yes",
        options: [
          { value: "yes", label: "Yes" },
          { value: "no", label: "No" }
        ]
      })
    },
    {
      // On Cancel callback that wraps the group
      // So if the user cancels one of the prompts in the group this function will be called
      onCancel: () => {
        p.cancel("Operation cancelled.");
        process.exit(0);
      }
    }
  );
  p.outro("Let's get started! \u{1F43C}");
  return {
    postcss: initFlags.usePostcss === "yes",
    outExtension: initFlags.useMjsExtension === "yes" ? "mjs" : "js",
    jsxFramework: initFlags.jsxOptions.jsxFramework,
    syntax: initFlags.whatSyntax,
    strictTokens: initFlags.withStrictTokens === "yes",
    gitignore: initFlags.shouldUpdateGitignore === "yes"
  };
};

// src/cli-main.ts
async function main() {
  const cli = (0, import_cac.cac)("panda");
  const cwd = process.cwd();
  cli.command("init", "Initialize the panda's config file").option("-i, --interactive", "Run in interactive mode", { default: false }).option("-f, --force", "Force overwrite existing config file").option("-p, --postcss", "Emit postcss config file").option("-c, --config <path>", "Path to panda config file").option("--cwd <cwd>", "Current working directory", { default: cwd }).option("--silent", "Suppress all messages except errors").option("--no-gitignore", "Don't update the .gitignore").option("--out-extension <ext>", "The extension of the generated js files (default: 'mjs')").option("--jsx-framework <framework>", "The jsx framework to use").option("--syntax <syntax>", "The css syntax preference").option("--strict-tokens", "Using strictTokens: true").action(async (initFlags = {}) => {
    let options = {};
    if (initFlags.interactive) {
      options = await interactive();
    }
    const flags = { ...initFlags, ...options };
    const { force, postcss, silent, gitignore, outExtension, jsxFramework, config: configPath, syntax } = flags;
    const cwd2 = (0, import_pathe.resolve)(flags.cwd ?? "");
    if (silent) {
      import_logger.logger.level = "silent";
    }
    import_logger.logger.info("cli", `Panda v${version}
`);
    const done = import_logger.logger.time.info("\u2728 Panda initialized");
    if (postcss) {
      await (0, import_node.setupPostcss)(cwd2);
    }
    await (0, import_node.setupConfig)(cwd2, { force, outExtension, jsxFramework, syntax });
    const ctx = await (0, import_node.loadConfigAndCreateContext)({ cwd: cwd2, configPath });
    const { msg, box } = await (0, import_node.emitArtifacts)(ctx);
    if (gitignore) {
      (0, import_node.setupGitIgnore)(ctx);
    }
    import_logger.logger.log(msg + box);
    done();
  });
  cli.command("codegen", "Generate the panda system").option("--silent", "Don't print any logs").option("--clean", "Clean the output directory before generating").option("-c, --config <path>", "Path to panda config file").option("-w, --watch", "Watch files and rebuild").option("-p, --poll", "Use polling instead of filesystem events when watching").option("--cwd <cwd>", "Current working directory", { default: cwd }).action(async (flags) => {
    const { silent, clean, config: configPath, watch, poll } = flags;
    const cwd2 = (0, import_pathe.resolve)(flags.cwd ?? "");
    if (silent) {
      import_logger.logger.level = "silent";
    }
    const ctx = await (0, import_node.loadConfigAndCreateContext)({ cwd: cwd2, config: { clean }, configPath });
    const { msg } = await (0, import_node.emitArtifacts)(ctx);
    import_logger.logger.log(msg);
    if (watch) {
      import_logger.logger.info("ctx:watch", ctx.messages.configWatch());
      const watcher = ctx.runtime.fs.watch({
        include: ctx.conf.dependencies,
        cwd: cwd2,
        poll
      });
      const onChange = (0, import_perfect_debounce.debounce)(async () => {
        import_logger.logger.info("ctx:change", "config changed, rebuilding...");
        const affecteds = await ctx.diff.reloadConfigAndRefreshContext();
        await (0, import_node.emitArtifacts)(ctx, Array.from(affecteds.artifacts));
        import_logger.logger.info("ctx:updated", "config rebuilt \u2705");
      });
      watcher.on("change", onChange);
    }
  });
  cli.command(
    "cssgen [globOrType]",
    "Generate the css from files, or generate the css from the specified type which can be: preflight, tokens, static, global, keyframes"
  ).option("--silent", "Don't print any logs").option("-m, --minify", "Minify generated code").option("--clean", "Clean the output before generating").option("-c, --config <path>", "Path to panda config file").option("-w, --watch", "Watch files and rebuild").option("--minimal", "Do not include CSS generation for theme tokens, preflight, keyframes, static and global css").option("-p, --poll", "Use polling instead of filesystem events when watching").option("-o, --outfile [file]", "Output file for extracted css, default to './styled-system/styles.css'").option("--cwd <cwd>", "Current working directory", { default: cwd }).action(async (maybeGlob, flags = {}) => {
    const { silent, clean, config: configPath, outfile, watch, poll, minify, minimal } = flags;
    const cwd2 = (0, import_pathe.resolve)(flags.cwd ?? "");
    const cssArtifact = ["preflight", "tokens", "static", "global", "keyframes"].find(
      (type) => type === maybeGlob
    );
    const glob = cssArtifact ? void 0 : maybeGlob;
    if (silent) {
      import_logger.logger.level = "silent";
    }
    const overrideConfig = {
      clean,
      minify,
      optimize: true,
      ...glob ? { include: [glob] } : void 0
    };
    let ctx = await (0, import_node.loadConfigAndCreateContext)({
      cwd: cwd2,
      config: overrideConfig,
      configPath
    });
    const ensureFile = (ctx2, file) => {
      const outPath = (0, import_pathe.resolve)(cwd2, file);
      const dirname = ctx2.runtime.path.dirname(outPath);
      ctx2.runtime.fs.ensureDirSync(dirname);
    };
    const cssgen = async (ctx2) => {
      if (cssArtifact) {
        ctx2.appendCss(cssArtifact);
        if (outfile) {
          ensureFile(ctx2, outfile);
          ctx2.runtime.fs.writeFileSync(outfile, ctx2.getCss());
        } else {
          await ctx2.writeCss();
        }
        const msg = ctx2.messages.cssArtifactComplete(cssArtifact);
        import_logger.logger.info("css:emit:artifact", msg);
      } else {
        if (!minimal) {
          ctx2.appendLayerParams();
          ctx2.appendBaselineCss();
        }
        const files = ctx2.appendFilesCss();
        if (outfile) {
          ensureFile(ctx2, outfile);
          ctx2.runtime.fs.writeFileSync(outfile, ctx2.getCss());
        } else {
          await ctx2.writeCss();
        }
        const msg = ctx2.messages.buildComplete(files.length);
        import_logger.logger.info("css:emit:out", msg);
      }
    };
    await cssgen(ctx);
    if (watch) {
      import_logger.logger.info("ctx:watch", ctx.messages.configWatch());
      const configWatcher = ctx.runtime.fs.watch({ include: ctx.conf.dependencies, cwd: cwd2, poll });
      configWatcher.on(
        "change",
        (0, import_perfect_debounce.debounce)(async () => {
          import_logger.logger.info("ctx:change", "config changed, rebuilding...");
          await ctx.diff.reloadConfigAndRefreshContext((conf) => {
            ctx = new import_node.PandaContext({ ...conf, hooks: ctx.hooks });
          });
          await cssgen(ctx);
          import_logger.logger.info("ctx:updated", "config rebuilt \u2705");
        })
      );
      const contentWatcher = ctx.runtime.fs.watch(ctx.config);
      contentWatcher.on(
        "all",
        (0, import_perfect_debounce.debounce)(async (event, file) => {
          import_logger.logger.info(`file:${event}`, file);
          if (event === "unlink") {
            ctx.project.removeSourceFile(ctx.runtime.path.abs(cwd2, file));
          } else if (event === "change") {
            ctx.project.reloadSourceFile(file);
            await cssgen(ctx);
          } else if (event === "add") {
            ctx.project.createSourceFile(file);
            await cssgen(ctx);
          }
        })
      );
      import_logger.logger.info("ctx:watch", ctx.messages.watch());
    }
  });
  cli.command("[files]", "Include file glob", { ignoreOptionDefaultValue: true }).option("-o, --outdir <dir>", "Output directory", { default: "styled-system" }).option("-m, --minify", "Minify generated code").option("-w, --watch", "Watch files and rebuild").option("-p, --poll", "Use polling instead of filesystem events when watching").option("-c, --config <path>", "Path to panda config file").option("--cwd <cwd>", "Current working directory", { default: cwd }).option("--preflight", "Enable css reset").option("--silent", "Suppress all messages except errors").option("-e, --exclude <files>", "Exclude files", { default: [] }).option("--clean", "Clean output directory").option("--hash", "Hash the generated classnames to make them shorter").option("--emitTokensOnly", "Whether to only emit the `tokens` directory").action(async (files, flags) => {
    const { config: configPath, silent, ...rest } = flags;
    const cwd2 = (0, import_pathe.resolve)(flags.cwd);
    if (silent) {
      import_logger.logger.level = "silent";
    }
    const config = (0, import_shared.compact)({ include: files, ...rest, cwd: cwd2 });
    await (0, import_node.generate)(config, configPath);
  });
  cli.command("studio", "Realtime documentation for your design tokens").option("--build", "Build").option("--preview", "Preview").option("--port <port>", "Port").option("--host", "Host").option("-c, --config <path>", "Path to panda config file").option("--cwd <cwd>", "Current working directory", { default: cwd }).option("--outdir", "Output directory for static files").action(async (flags) => {
    const { build, preview, port, host, outdir, config } = flags;
    const cwd2 = (0, import_pathe.resolve)(flags.cwd ?? "");
    const ctx = await (0, import_node.loadConfigAndCreateContext)({
      cwd: cwd2,
      configPath: config
    });
    const buildOpts = {
      configPath: (0, import_config.findConfigFile)({ cwd: cwd2, file: config }),
      outDir: (0, import_pathe.resolve)(outdir || ctx.studio.outdir),
      port,
      host
    };
    let studio;
    try {
      const studioPath = require.resolve("@pandacss/studio", { paths: [cwd2] });
      studio = require(studioPath);
    } catch (error) {
      import_logger.logger.error("studio", error);
      throw new Error("You need to install '@pandacss/studio' to use this command");
    }
    if (preview) {
      await studio.previewStudio(buildOpts);
    } else if (build) {
      await studio.buildStudio(buildOpts);
    } else {
      await studio.serveStudio(buildOpts);
      const note = `use ${import_logger.colors.reset(import_logger.colors.bold("--build"))} to build`;
      const port2 = `use ${import_logger.colors.reset(import_logger.colors.bold("--port"))} for a different port`;
      import_logger.logger.log(import_logger.colors.dim(`  ${import_logger.colors.green("\u279C")}  ${import_logger.colors.bold("Build")}: ${note}`));
      import_logger.logger.log(import_logger.colors.dim(`  ${import_logger.colors.green("\u279C")}  ${import_logger.colors.bold("Port")}: ${port2}`));
    }
  });
  cli.command("analyze [glob]", "Analyze design token usage in glob").option("--json [filepath]", "Output analyze report in JSON").option("--silent", "Don't print any logs").option("-c, --config <path>", "Path to panda config file").option("--cwd <cwd>", "Current working directory", { default: cwd }).action(async (maybeGlob, flags = {}) => {
    const { silent, config: configPath } = flags;
    const cwd2 = (0, import_pathe.resolve)(flags.cwd);
    if (silent) {
      import_logger.logger.level = "silent";
    }
    const ctx = await (0, import_node.loadConfigAndCreateContext)({
      cwd: cwd2,
      config: maybeGlob ? { include: [maybeGlob] } : void 0,
      configPath
    });
    const result = (0, import_node.analyzeTokens)(ctx, {
      onResult(file) {
        import_logger.logger.info("cli", `Analyzed ${import_logger.colors.bold(file)}`);
      }
    });
    if (flags?.json && typeof flags.json === "string") {
      await (0, import_node.writeAnalyzeJSON)(flags.json, result, ctx);
      import_logger.logger.info("cli", `JSON report saved to ${flags.json}`);
      return;
    }
    import_logger.logger.info("cli", `Found ${result.details.byId.size} token used in ${result.details.byFilePathMaps.size} files`);
  });
  cli.command("debug [glob]", "Debug design token extraction & css generated from files in glob").option("--silent", "Don't print any logs").option("--dry", "Output debug files in stdout without writing to disk").option("--outdir [dir]", "Output directory for debug files, default to './styled-system/debug'").option("--only-config", "Should only output the config file, default to 'false'").option("-c, --config <path>", "Path to panda config file").option("--cwd <cwd>", "Current working directory", { default: cwd }).action(async (maybeGlob, flags = {}) => {
    const { silent, dry = false, outdir: outdirFlag, config: configPath } = flags ?? {};
    const cwd2 = (0, import_pathe.resolve)(flags.cwd);
    if (silent) {
      import_logger.logger.level = "silent";
    }
    const ctx = await (0, import_node.loadConfigAndCreateContext)({
      cwd: cwd2,
      config: maybeGlob ? { include: [maybeGlob] } : void 0,
      configPath
    });
    const outdir = outdirFlag ?? (0, import_pathe.join)(...ctx.paths.root, "debug");
    await (0, import_node.debugFiles)(ctx, { outdir, dry, onlyConfig: flags.onlyConfig });
  });
  cli.command("ship [glob]", "Ship extract result from files in glob").option("--silent", "Don't print any logs").option(
    "--o, --outfile [file]",
    "Output path for the build info file, default to './styled-system/panda.buildinfo.json'"
  ).option("-m, --minify", "Minify generated JSON file").option("-c, --config <path>", "Path to panda config file").option("--cwd <cwd>", "Current working directory", { default: cwd }).option("-w, --watch", "Watch files and rebuild").option("-p, --poll", "Use polling instead of filesystem events when watching").action(async (maybeGlob, flags = {}) => {
    const { silent, outfile: outfileFlag, minify, config: configPath, watch, poll } = flags;
    const cwd2 = (0, import_pathe.resolve)(flags.cwd);
    if (silent) {
      import_logger.logger.level = "silent";
    }
    let ctx = await (0, import_node.loadConfigAndCreateContext)({
      cwd: cwd2,
      config: maybeGlob ? { include: [maybeGlob] } : void 0,
      configPath
    });
    const outfile = outfileFlag ?? (0, import_pathe.join)(...ctx.paths.root, "panda.buildinfo.json");
    if (minify) {
      ctx.config.minify = true;
    }
    await (0, import_node.shipFiles)(ctx, outfile);
    if (watch) {
      import_logger.logger.info("ctx:watch", ctx.messages.configWatch());
      const configWatcher = ctx.runtime.fs.watch({ include: ctx.conf.dependencies, cwd: cwd2, poll });
      configWatcher.on(
        "change",
        (0, import_perfect_debounce.debounce)(async () => {
          import_logger.logger.info("ctx:change", "config changed, rebuilding...");
          await ctx.diff.reloadConfigAndRefreshContext((conf) => {
            ctx = new import_node.PandaContext({ ...conf, hooks: ctx.hooks });
          });
          await (0, import_node.shipFiles)(ctx, outfile);
          import_logger.logger.info("ctx:updated", "config rebuilt \u2705");
        })
      );
      const contentWatcher = ctx.runtime.fs.watch(ctx.config);
      contentWatcher.on(
        "all",
        (0, import_perfect_debounce.debounce)(async (event, file) => {
          import_logger.logger.info(`file:${event}`, file);
          if (event === "unlink") {
            ctx.project.removeSourceFile(ctx.runtime.path.abs(cwd2, file));
          } else if (event === "change") {
            ctx.project.reloadSourceFile(file);
            await (0, import_node.shipFiles)(ctx, outfile);
          } else if (event === "add") {
            ctx.project.createSourceFile(file);
            await (0, import_node.shipFiles)(ctx, outfile);
          }
        })
      );
      import_logger.logger.info("ctx:watch", ctx.messages.watch());
    }
  });
  cli.help();
  cli.version(version);
  cli.parse(process.argv, { run: false });
  try {
    await cli.runMatchedCommand();
  } catch (error) {
    import_logger.logger.error("cli", error);
    if (import_logger.logger.isDebug) {
      console.error(error);
    }
    process.exit(1);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  main
});
