// src/get-placement.ts
import { arrow, computePosition, flip, offset, shift, size } from "@floating-ui/dom";
import { raf } from "@zag-js/dom-query";
import { callAll as callAll2, compact } from "@zag-js/utils";

// src/auto-update.ts
import { getOverflowAncestors } from "@floating-ui/dom";
import { trackElementRect } from "@zag-js/element-rect";
var callAll = (...fns) => () => fns.forEach((fn) => fn());
var isHTMLElement = (el) => {
  return typeof el === "object" && el !== null && el.nodeType === 1;
};
var addDomEvent = (el, type, fn, options) => {
  el.addEventListener(type, fn, options);
  return () => el.removeEventListener(type, fn, options);
};
function resolveOptions(option) {
  const bool = typeof option === "boolean";
  return {
    ancestorResize: bool ? option : option.ancestorResize ?? true,
    ancestorScroll: bool ? option : option.ancestorScroll ?? true,
    referenceResize: bool ? option : option.referenceResize ?? true
  };
}
function autoUpdate(reference, floating, update, options = false) {
  const { ancestorScroll, ancestorResize, referenceResize } = resolveOptions(options);
  const useAncestors = ancestorScroll || ancestorResize;
  const ancestors = [];
  if (useAncestors && isHTMLElement(reference)) {
    ancestors.push(...getOverflowAncestors(reference));
  }
  function addResizeListeners() {
    let cleanups = [trackElementRect(floating, { scope: "size", onChange: update })];
    if (referenceResize && isHTMLElement(reference)) {
      cleanups.push(trackElementRect(reference, { onChange: update }));
    }
    cleanups.push(callAll(...ancestors.map((el) => addDomEvent(el, "resize", update))));
    return () => cleanups.forEach((fn) => fn());
  }
  function addScrollListeners() {
    return callAll(...ancestors.map((el) => addDomEvent(el, "scroll", update, { passive: true })));
  }
  return callAll(addResizeListeners(), addScrollListeners());
}

// src/middleware.ts
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow2) => ({
  top: "bottom center",
  "top-start": arrow2 ? `${arrow2.x}px bottom` : "left bottom",
  "top-end": arrow2 ? `${arrow2.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow2 ? `${arrow2.x}px top` : "top left",
  "bottom-end": arrow2 ? `${arrow2.x}px top` : "top right",
  left: "right center",
  "left-start": arrow2 ? `right ${arrow2.y}px` : "right top",
  "left-end": arrow2 ? `right ${arrow2.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow2 ? `left ${arrow2.y}px` : "left top",
  "right-end": arrow2 ? `left ${arrow2.y}px` : "left bottom"
});
var transformOrigin = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow2 } = middlewareData;
    const transformOrigin2 = getTransformOrigin(arrow2)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin2);
    return {
      data: { transformOrigin: transformOrigin2 }
    };
  }
};
var shiftArrow = (opts) => ({
  name: "shiftArrow",
  fn({ placement, middlewareData }) {
    const { element: arrow2 } = opts;
    if (middlewareData.arrow) {
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrow2.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
    }
    return {};
  }
});

// src/get-placement.ts
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  sameWidth: false,
  overflowPadding: 8
};
function getPlacementImpl(reference, floating, opts = {}) {
  if (!floating || !reference)
    return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [];
  const boundary = typeof options.boundary === "function" ? options.boundary() : options.boundary;
  if (options.flip) {
    middleware.push(
      flip({
        boundary,
        padding: options.overflowPadding
      })
    );
  }
  if (options.gutter || options.offset) {
    const arrowOffset = arrowEl ? arrowEl.offsetHeight / 2 : 0;
    let mainAxis = options.offset?.mainAxis ?? options.gutter;
    let crossAxis = options.offset?.crossAxis;
    if (mainAxis != null)
      mainAxis += arrowOffset;
    const offsetOptions = compact({ mainAxis, crossAxis });
    middleware.push(offset(offsetOptions));
  }
  middleware.push(
    shift({
      boundary,
      crossAxis: options.overlap,
      padding: options.overflowPadding
    })
  );
  if (arrowEl) {
    middleware.push(
      arrow({ element: arrowEl, padding: 8 }),
      shiftArrow({ element: arrowEl })
    );
  }
  middleware.push(transformOrigin);
  middleware.push(
    size({
      padding: options.overflowPadding,
      apply({ rects, availableHeight, availableWidth }) {
        const referenceWidth = Math.round(rects.reference.width);
        floating.style.setProperty("--reference-width", `${referenceWidth}px`);
        floating.style.setProperty("--available-width", `${availableWidth}px`);
        floating.style.setProperty("--available-height", `${availableHeight}px`);
      }
    })
  );
  function compute(config = {}) {
    if (!reference || !floating)
      return;
    const { placement, strategy, onComplete } = options;
    computePosition(reference, floating, {
      placement,
      middleware,
      strategy,
      ...config
    }).then((data) => {
      const x = Math.round(data.x);
      floating.style.setProperty("--x", `${x}px`);
      const y = Math.round(data.y);
      floating.style.setProperty("--y", `${y}px`);
      onComplete?.(data);
    });
  }
  compute();
  return callAll2(
    options.listeners ? autoUpdate(reference, floating, compute, options.listeners) : void 0,
    options.onCleanup
  );
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...restOptions } = opts;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups.push(getPlacementImpl(reference, floating, restOptions));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}

// src/get-styles.ts
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
  const { placement = "bottom", sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      transform: ARROW_FLOATING_STYLE[placement.split("-")[0]],
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      top: "0px",
      left: "0px",
      transform: `translate3d(var(--x), var(--y), 0)`
    }
  };
}
export {
  getBasePlacement,
  getPlacement,
  getPlacementStyles
};
//# sourceMappingURL=index.mjs.map