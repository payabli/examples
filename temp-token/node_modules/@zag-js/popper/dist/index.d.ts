import { Placement, Boundary, ComputePositionReturn, VirtualElement } from '@floating-ui/dom';
export { Boundary, ComputePositionReturn, Placement } from '@floating-ui/dom';

type AutoUpdateOptions = {
    ancestorScroll?: boolean;
    ancestorResize?: boolean;
    referenceResize?: boolean;
};

type PositioningOptions = {
    /**
     * The strategy to use for positioning
     */
    strategy?: "absolute" | "fixed";
    /**
     * The initial placement of the floating element
     */
    placement?: Placement;
    /**
     * The offset of the floating element
     */
    offset?: {
        mainAxis?: number;
        crossAxis?: number;
    };
    /**
     * The main axis offset or gap between the reference and floating elements
     */
    gutter?: number;
    /**
     * The virtual padding around the viewport edges to check for overflow
     */
    overflowPadding?: number;
    /**
     * Whether to flip the placement
     */
    flip?: boolean;
    /**
     * Whether the floating element can overlap the reference element
     * @default false
     */
    overlap?: boolean;
    /**
     * Whether to make the floating element same width as the reference element
     */
    sameWidth?: boolean;
    /**
     * Whether the popover should fit the viewport.
     */
    fitViewport?: boolean;
    /**
     * The overflow boundary of the reference element
     */
    boundary?: Boundary | (() => Boundary);
    /**
     * Options to activate auto-update listeners
     */
    listeners?: boolean | AutoUpdateOptions;
    /**
     * Function called when the placement is computed
     */
    onComplete?(data: ComputePositionReturn): void;
    /**
     * Function called on cleanup of all listeners
     */
    onCleanup?: VoidFunction;
};
type BasePlacement = "top" | "right" | "bottom" | "left";

type MaybeRectElement = HTMLElement | VirtualElement | null;
type MaybeElement = HTMLElement | null;
type MaybeFn<T> = T | (() => T);
declare function getBasePlacement(placement: Placement): BasePlacement;
declare function getPlacement(referenceOrFn: MaybeFn<MaybeRectElement>, floatingOrFn: MaybeFn<MaybeElement>, opts?: PositioningOptions & {
    defer?: boolean;
}): () => void;

type GetPlacementStylesOptions = {
    placement?: Placement;
};
declare function getPlacementStyles(options?: PositioningOptions): {
    arrow: {
        readonly [x: string]: string;
        readonly position: "absolute";
        readonly width: string;
        readonly height: string;
    };
    arrowTip: {
        readonly transform: any;
        readonly background: string;
        readonly top: "0";
        readonly left: "0";
        readonly width: "100%";
        readonly height: "100%";
        readonly position: "absolute";
        readonly zIndex: "inherit";
    };
    floating: {
        readonly position: "absolute" | "fixed";
        readonly minWidth: "max-content" | undefined;
        readonly width: "var(--reference-width)" | undefined;
        readonly maxWidth: "var(--available-width)" | undefined;
        readonly maxHeight: "var(--available-height)" | undefined;
        readonly top: "0px";
        readonly left: "0px";
        readonly transform: "translate3d(var(--x), var(--y), 0)";
    };
};

export { AutoUpdateOptions, BasePlacement, GetPlacementStylesOptions, PositioningOptions, getBasePlacement, getPlacement, getPlacementStyles };
