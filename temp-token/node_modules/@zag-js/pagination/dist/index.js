"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/pagination.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("pagination").parts(
  "root",
  "pageTrigger",
  "ellipsis",
  "prevPageTrigger",
  "nextPageTrigger"
);
var parts = anatomy.build();

// src/pagination.connect.ts
var import_dom_query2 = require("@zag-js/dom-query");

// src/pagination.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var dom = (0, import_dom_query.createScope)({
  getRootId: (ctx) => ctx.ids?.root ?? `pagination:${ctx.id}`,
  getPrevPageTriggerId: (ctx) => ctx.ids?.prevPageTrigger ?? `pagination:${ctx.id}:prev`,
  getNextPageTriggerId: (ctx) => ctx.ids?.nextPageTrigger ?? `pagination:${ctx.id}:next`,
  getEllipsisId: (ctx, index) => ctx.ids?.ellipsis?.(index) ?? `pagination:${ctx.id}:ellipsis:${index}`,
  getPageTriggerId: (ctx, page) => ctx.ids?.pageTrigger?.(page) ?? `pagination:${ctx.id}:item:${page}`
});

// src/pagination.utils.ts
var utils = {
  range: (start, end) => {
    let length = end - start + 1;
    return Array.from({ length }, (_, idx) => idx + start);
  },
  transform: (items) => {
    return items.map((value) => {
      if (typeof value === "number")
        return { type: "page", value };
      return { type: "ellipsis" };
    });
  },
  getRange: (ctx) => {
    const totalPageNumbers = ctx.siblingCount + 5;
    if (totalPageNumbers >= ctx.totalPages)
      return utils.transform(utils.range(1, ctx.totalPages));
    const ELLIPSIS = "ellipsis";
    const leftSiblingIndex = Math.max(ctx.page - ctx.siblingCount, 1);
    const rightSiblingIndex = Math.min(ctx.page + ctx.siblingCount, ctx.totalPages);
    const showLeftEllipsis = leftSiblingIndex > 2;
    const showRightEllipsis = rightSiblingIndex < ctx.totalPages - 2;
    const firstPageIndex = 1;
    const lastPageIndex = ctx.totalPages;
    if (!showLeftEllipsis && showRightEllipsis) {
      let leftItemCount = 3 + 2 * ctx.siblingCount;
      let leftRange = utils.range(1, leftItemCount);
      return utils.transform([...leftRange, ELLIPSIS, ctx.totalPages]);
    }
    if (showLeftEllipsis && !showRightEllipsis) {
      let rightItemCount = 3 + 2 * ctx.siblingCount;
      let rightRange = utils.range(ctx.totalPages - rightItemCount + 1, ctx.totalPages);
      return utils.transform([firstPageIndex, ELLIPSIS, ...rightRange]);
    }
    if (showLeftEllipsis && showRightEllipsis) {
      let middleRange = utils.range(leftSiblingIndex, rightSiblingIndex);
      return utils.transform([firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex]);
    }
    return [];
  }
};

// src/pagination.connect.ts
function connect(state, send, normalize) {
  const totalPages = state.context.totalPages;
  const page = state.context.page;
  const translations = state.context.translations;
  const previousPage = state.context.previousPage;
  const nextPage = state.context.nextPage;
  const pageRange = state.context.pageRange;
  const type = state.context.type;
  const isButton = type === "button";
  const isFirstPage = page === 1;
  const isLastPage = page === totalPages;
  return {
    page,
    totalPages,
    pages: utils.getRange(state.context),
    previousPage,
    nextPage,
    pageRange,
    isFirstPage,
    isLastPage,
    slice(data) {
      return data.slice(pageRange.start, pageRange.end);
    },
    setCount(count) {
      send({ type: "SET_COUNT", count });
    },
    setPageSize(size) {
      send({ type: "SET_PAGE_SIZE", size });
    },
    setPage(page2) {
      send({ type: "SET_PAGE", page: page2 });
    },
    rootProps: normalize.element({
      id: dom.getRootId(state.context),
      ...parts.root.attrs,
      "aria-label": translations.rootLabel
    }),
    getEllipsisProps(props) {
      return normalize.element({
        id: dom.getEllipsisId(state.context, props.index),
        ...parts.ellipsis.attrs
      });
    },
    getPageTriggerProps(page2) {
      const index = page2.value;
      const isCurrentPage = index === state.context.page;
      return normalize.element({
        id: dom.getPageTriggerId(state.context, index),
        ...parts.pageTrigger.attrs,
        "data-selected": (0, import_dom_query2.dataAttr)(isCurrentPage),
        "aria-current": isCurrentPage ? "page" : void 0,
        "aria-label": translations.pageTriggerLabel?.({ page: index, totalPages }),
        onClick() {
          send({ type: "SET_PAGE", page: index });
        },
        ...isButton && { type: "button" }
      });
    },
    prevPageTriggerProps: normalize.element({
      id: dom.getPrevPageTriggerId(state.context),
      ...parts.prevPageTrigger.attrs,
      "data-disabled": (0, import_dom_query2.dataAttr)(isFirstPage),
      "aria-label": translations.prevPageTriggerLabel,
      onClick() {
        send({ type: "PREVIOUS_PAGE" });
      },
      ...isButton && { disabled: isFirstPage, type: "button" }
    }),
    nextPageTriggerProps: normalize.element({
      id: dom.getNextPageTriggerId(state.context),
      ...parts.nextPageTrigger.attrs,
      "data-disabled": (0, import_dom_query2.dataAttr)(isLastPage),
      "aria-label": translations.nextPageTriggerLabel,
      onClick() {
        send({ type: "NEXT_PAGE" });
      },
      ...isButton && { disabled: isLastPage, type: "button" }
    })
  };
}

// src/pagination.machine.ts
var import_core = require("@zag-js/core");
var import_utils = require("@zag-js/utils");
function machine(userContext) {
  const ctx = (0, import_utils.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "pagination",
      initial: "idle",
      context: {
        pageSize: 10,
        siblingCount: 1,
        page: 1,
        type: "button",
        translations: {
          rootLabel: "pagination",
          prevPageTriggerLabel: "previous page",
          nextPageTriggerLabel: "next page",
          pageTriggerLabel({ page, totalPages }) {
            const isLastPage = totalPages > 1 && page === totalPages;
            return `${isLastPage ? "last page, " : ""}page ${page}`;
          },
          ...ctx.translations
        },
        ...ctx
      },
      watch: {
        pageSize: ["setPageIfNeeded"]
      },
      computed: {
        totalPages: (ctx2) => Math.ceil(ctx2.count / ctx2.pageSize),
        previousPage: (ctx2) => ctx2.page === 1 ? null : ctx2.page - 1,
        nextPage: (ctx2) => ctx2.page === ctx2.totalPages ? null : ctx2.page + 1,
        pageRange: (ctx2) => {
          const start = (ctx2.page - 1) * ctx2.pageSize;
          const end = start + ctx2.pageSize;
          return { start, end };
        },
        isValidPage: (ctx2) => ctx2.page >= 1 && ctx2.page <= ctx2.totalPages
      },
      on: {
        SET_COUNT: [
          {
            guard: "isValidCount",
            actions: ["setCount", "goToFirstPage"]
          },
          {
            actions: "setCount"
          }
        ],
        SET_PAGE: {
          guard: "isValidPage",
          actions: "setPage"
        },
        SET_PAGE_SIZE: {
          actions: "setPageSize"
        },
        PREVIOUS_PAGE: {
          guard: "canGoToPrevPage",
          actions: "goToPrevPage"
        },
        NEXT_PAGE: {
          guard: "canGoToNextPage",
          actions: "goToNextPage"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isValidPage: (ctx2, evt) => evt.page >= 1 && evt.page <= ctx2.totalPages,
        isValidCount: (ctx2, evt) => ctx2.page > evt.count,
        canGoToNextPage: (ctx2) => ctx2.page < ctx2.totalPages,
        canGoToPrevPage: (ctx2) => ctx2.page > 1
      },
      actions: {
        setCount(ctx2, evt) {
          ctx2.count = evt.count;
        },
        setPage(ctx2, evt) {
          ctx2.page = evt.page;
        },
        setPageSize(ctx2, evt) {
          ctx2.pageSize = evt.size;
        },
        goToFirstPage(ctx2) {
          set.page(ctx2, 1);
        },
        goToPrevPage(ctx2) {
          set.page(ctx2, ctx2.page - 1);
        },
        goToNextPage(ctx2) {
          set.page(ctx2, ctx2.page + 1);
        },
        setPageIfNeeded(ctx2, _evt) {
          if (ctx2.isValidPage)
            return;
          set.page(ctx2, 1);
        }
      }
    }
  );
}
var set = {
  page: (ctx, value) => {
    if ((0, import_utils.isEqual)(ctx.page, value))
      return;
    ctx.page = value;
    ctx.onChange?.({ page: ctx.page, pageSize: ctx.pageSize });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine
});
//# sourceMappingURL=index.js.map