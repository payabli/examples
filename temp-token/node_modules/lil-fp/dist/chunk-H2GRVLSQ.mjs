import {
  cast
} from "./chunk-BK5YMWOD.mjs";
import {
  isFunc,
  isObj
} from "./chunk-3XTOLKPS.mjs";
import {
  __export
} from "./chunk-LLLY6SAS.mjs";

// src/obj.ts
var obj_exports = {};
__export(obj_exports, {
  assign: () => assign,
  assignTo: () => assignTo,
  bind: () => bind,
  compact: () => compact,
  defaults: () => defaults,
  entries: () => entries,
  filter: () => filter,
  fromEntries: () => fromEntries,
  get: () => get,
  keys: () => keys,
  map: () => map,
  merge: () => merge,
  omit: () => omit,
  pick: () => pick,
  split: () => split
});
var fromEntries = (entries2) => Object.fromEntries(entries2), map = (f) => (obj) => fromEntries(Object.entries(obj).map(([k, v]) => f(k, v))), entries = (obj) => Object.entries(obj);
function assign(v) {
  return (obj) => ({
    ...obj,
    ...isFunc(v) ? v(obj) : v
  });
}
var assignTo = (key) => (prev) => fromEntries([[key, prev]]), bind = (key, fn) => (obj) => cast({
  ...obj,
  [key]: fn(obj)
}), keys = (obj) => Object.keys(obj), filter = (f) => (obj) => fromEntries(Object.entries(obj).filter(([k, v]) => f(k, v))), compact = (obj) => filter((_, v) => v != null)(obj), split = (...keys2) => (obj) => {
  let descriptors = Object.getOwnPropertyDescriptors(obj), dKeys = Object.keys(descriptors), split2 = (k) => {
    let clone = {};
    for (let i = 0; i < k.length; i++) {
      let key = k[i];
      descriptors[key] && (Object.defineProperty(clone, key, descriptors[key]), delete descriptors[key]);
    }
    return clone;
  }, fn = (key) => split2(Array.isArray(key) ? key : dKeys.filter(key));
  return keys2.map(fn).concat(split2(dKeys));
};
function merge(...args) {
  return (obj) => {
    if (!args.length)
      return obj;
    for (let i = 1; i < args.length; i++) {
      let source = { ...args[i] };
      for (let key in source) {
        let targValue = obj[key], srcValue = source[key];
        isObj(targValue) && isObj(srcValue) ? obj[key] = merge(srcValue)(targValue) : obj[key] = srcValue;
      }
    }
    return obj;
  };
}
var omit = (keys2) => (obj) => {
  let clone = { ...obj };
  for (let i = 0; i < keys2.length; i++)
    delete clone[keys2[i]];
  return clone;
}, pick = (keys2) => (obj) => {
  let clone = {};
  for (let i = 0; i < keys2.length; i++)
    clone[keys2[i]] = obj[keys2[i]];
  return clone;
}, defaults = (defaults2) => (obj) => cast({
  ...defaults2,
  ...obj
}), isSafeKey = (key) => key !== "__proto__" && key !== "prototype" && key !== "constructor", get = (path, undef) => (obj) => {
  let keys2 = Array.isArray(path) ? path : path.split(".");
  for (let i = 0; i < keys2.length; i++) {
    let key = keys2[i];
    if (!obj || !Object.prototype.hasOwnProperty.call(obj, key) || !isSafeKey(key)) {
      obj = void 0;
      break;
    }
    obj = obj[key];
  }
  return cast(obj ?? undef);
};

export {
  fromEntries,
  map,
  entries,
  assign,
  assignTo,
  bind,
  keys,
  filter,
  compact,
  split,
  merge,
  omit,
  pick,
  defaults,
  get,
  obj_exports
};
