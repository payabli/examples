/**
 * Combines multiple boolean predicates using OR → a || b.
 */
declare function or<A, B extends A, C extends A>(a: (v: A) => v is B, b: (v: A) => v is C): (v: A) => v is B | C;
declare function or<A, B extends A, C extends A, D extends A>(a: (v: A) => v is B, b: (v: A) => v is C, c: (v: A) => v is D): (v: A) => v is B | C | D;
declare function or<A, B extends A, C extends A, D extends A, E extends A>(a: (v: A) => v is B, b: (v: A) => v is C, c: (v: A) => v is D, d: (v: A) => v is E): (v: A) => v is B | C | D | E;
/**
 * Inverts a boolean predicate.
 */
declare const not: <T>(predicate: (arg: T) => boolean) => (arg: T) => boolean;
/**
 * Combines multiple boolean predicates using AND → a && b.
 */
declare function and<A, B extends A, C extends A, D extends A, E extends A>(a: (v: A) => v is B, b: (v: A) => v is C, c: (v: A) => v is D, d: (v: A) => v is E): (v: A) => v is B & C & D & E;
declare function and<A, B extends A, C extends A, D extends A>(a: (v: A) => v is B, b: (v: A) => v is C, c: (v: A) => v is D): (v: A) => v is B & C & D;
declare function and<A, B extends A, C extends A>(a: (v: A) => v is B, b: (v: A) => v is C): (v: A) => v is B & C;

declare const bool_and: typeof and;
declare const bool_not: typeof not;
declare const bool_or: typeof or;
declare namespace bool {
  export {
    bool_and as and,
    bool_not as not,
    bool_or as or,
  };
}

export { and as a, bool as b, not as n, or as o };
