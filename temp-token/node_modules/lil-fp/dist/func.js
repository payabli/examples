"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// src/func.ts
var func_exports = {};
__export(func_exports, {
  cast: () => cast,
  flow: () => flow,
  identity: () => identity,
  log: () => log,
  memo: () => memo,
  noop: () => noop,
  pipe: () => pipe,
  tap: () => tap,
  tryCatch: () => tryCatch
});
module.exports = __toCommonJS(func_exports);
function pipe(input, ...functions) {
  return functions.reduce((acc, fn) => fn(acc), input);
}
function flow(...functions) {
  return (input) => functions.reduce((acc, fn) => fn(acc), input);
}
function tap(fn) {
  return (value) => (fn(value), value);
}
var log = (label, fn) => (v) => (console.log(`${label}: `, fn?.(v) ?? v), v), cast = (v) => v, noop = () => {
}, identity = (v) => v, memo = (fn) => {
  let cache = /* @__PURE__ */ Object.create(null);
  return (arg) => (cache[arg] === void 0 && (cache[arg] = fn(arg)), cache[arg]);
}, tryCatch = (fn, onError) => (v) => {
  try {
    return fn(v);
  } catch (err) {
    return cast(onError?.(err, v));
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  cast,
  flow,
  identity,
  log,
  memo,
  noop,
  pipe,
  tap,
  tryCatch
});
