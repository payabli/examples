"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// src/obj.ts
var obj_exports = {};
__export(obj_exports, {
  assign: () => assign,
  assignTo: () => assignTo,
  bind: () => bind,
  compact: () => compact,
  defaults: () => defaults,
  entries: () => entries,
  filter: () => filter,
  fromEntries: () => fromEntries,
  get: () => get,
  keys: () => keys,
  map: () => map,
  merge: () => merge,
  omit: () => omit,
  pick: () => pick,
  split: () => split
});
module.exports = __toCommonJS(obj_exports);

// src/func.ts
var cast = (v) => v;

// src/is.ts
var isArr = (x) => Array.isArray(x), isObj = (x) => x !== null && typeof x == "object" && !isArr(x), isFunc = (x) => typeof x == "function";

// src/obj.ts
var fromEntries = (entries2) => Object.fromEntries(entries2), map = (f) => (obj) => fromEntries(Object.entries(obj).map(([k, v]) => f(k, v))), entries = (obj) => Object.entries(obj);
function assign(v) {
  return (obj) => ({
    ...obj,
    ...isFunc(v) ? v(obj) : v
  });
}
var assignTo = (key) => (prev) => fromEntries([[key, prev]]), bind = (key, fn) => (obj) => cast({
  ...obj,
  [key]: fn(obj)
}), keys = (obj) => Object.keys(obj), filter = (f) => (obj) => fromEntries(Object.entries(obj).filter(([k, v]) => f(k, v))), compact = (obj) => filter((_, v) => v != null)(obj), split = (...keys2) => (obj) => {
  let descriptors = Object.getOwnPropertyDescriptors(obj), dKeys = Object.keys(descriptors), split2 = (k) => {
    let clone = {};
    for (let i = 0; i < k.length; i++) {
      let key = k[i];
      descriptors[key] && (Object.defineProperty(clone, key, descriptors[key]), delete descriptors[key]);
    }
    return clone;
  }, fn = (key) => split2(Array.isArray(key) ? key : dKeys.filter(key));
  return keys2.map(fn).concat(split2(dKeys));
};
function merge(...args) {
  return (obj) => {
    if (!args.length)
      return obj;
    for (let i = 1; i < args.length; i++) {
      let source = { ...args[i] };
      for (let key in source) {
        let targValue = obj[key], srcValue = source[key];
        isObj(targValue) && isObj(srcValue) ? obj[key] = merge(srcValue)(targValue) : obj[key] = srcValue;
      }
    }
    return obj;
  };
}
var omit = (keys2) => (obj) => {
  let clone = { ...obj };
  for (let i = 0; i < keys2.length; i++)
    delete clone[keys2[i]];
  return clone;
}, pick = (keys2) => (obj) => {
  let clone = {};
  for (let i = 0; i < keys2.length; i++)
    clone[keys2[i]] = obj[keys2[i]];
  return clone;
}, defaults = (defaults2) => (obj) => cast({
  ...defaults2,
  ...obj
}), isSafeKey = (key) => key !== "__proto__" && key !== "prototype" && key !== "constructor", get = (path, undef) => (obj) => {
  let keys2 = Array.isArray(path) ? path : path.split(".");
  for (let i = 0; i < keys2.length; i++) {
    let key = keys2[i];
    if (!obj || !Object.prototype.hasOwnProperty.call(obj, key) || !isSafeKey(key)) {
      obj = void 0;
      break;
    }
    obj = obj[key];
  }
  return cast(obj ?? undef);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assign,
  assignTo,
  bind,
  compact,
  defaults,
  entries,
  filter,
  fromEntries,
  get,
  keys,
  map,
  merge,
  omit,
  pick,
  split
});
