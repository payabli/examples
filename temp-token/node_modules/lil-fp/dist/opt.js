"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// src/opt.ts
var opt_exports = {};
__export(opt_exports, {
  filter: () => filter,
  flatMap: () => flatMap,
  fromExecution: () => fromExecution,
  fromNullable: () => fromNullable,
  fromPredicate: () => fromPredicate,
  getOrElse: () => getOrElse,
  getOrThrow: () => getOrThrow,
  isNone: () => isNone,
  isSome: () => isSome,
  map: () => map,
  match: () => match,
  none: () => none,
  orElse: () => orElse,
  some: () => some,
  tap: () => tap
});
module.exports = __toCommonJS(opt_exports);
var none = Object.freeze({ _tag: "None" }), some = (value) => Object.freeze({ _tag: "Some", value });
function fromPredicate(predicate) {
  return (v) => predicate(v) ? some(v) : none;
}
var fromNullable = (value) => value == null ? none : some(value), fromExecution = (value) => {
  try {
    return fromNullable(value());
  } catch {
    return none;
  }
}, isNone = (o) => o._tag === "None", isSome = (o) => o._tag === "Some", isOption = (o) => o._tag === "None" || o._tag === "Some", map = (f) => (o) => isNone(o) ? none : some(f(o.value)), flatMap = (f) => (o) => isNone(o) ? none : f(o.value), getOrElse = (def) => (o) => isNone(o) ? def() : o.value, getOrThrow = (msg) => (o) => {
  if (isNone(o))
    throw new Error(msg);
  return o.value;
}, match = (onSome, onNone) => (o) => isNone(o) ? onNone() : onSome(o.value), orElse = (v) => (o) => {
  let vv = v();
  return isOption(vv) ? isNone(o) ? vv : o : isNone(o) ? some(vv) : o;
}, tap = (f) => (o) => (isSome(o) && f(o.value), o), filter = (f) => (o) => isNone(o) ? none : f(o.value) ? o : none;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  filter,
  flatMap,
  fromExecution,
  fromNullable,
  fromPredicate,
  getOrElse,
  getOrThrow,
  isNone,
  isSome,
  map,
  match,
  none,
  orElse,
  some,
  tap
});
