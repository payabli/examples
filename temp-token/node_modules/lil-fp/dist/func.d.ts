/**
 * Performs left-to-right function composition (the first argument must be a value).
 */
declare function pipe<A, B>(value: A, fn1: (arg: A) => B): B;
declare function pipe<A, B, C>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C): C;
declare function pipe<A, B, C, D>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D): D;
declare function pipe<A, B, C, D, E>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E): E;
declare function pipe<A, B, C, D, E, F>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F): F;
declare function pipe<A, B, C, D, E, F, G>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G): G;
declare function pipe<A, B, C, D, E, F, G, H>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G, fn7: (arg: G) => H): H;
declare function pipe<A, B, C, D, E, F, G, H, I>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G, fn7: (arg: G) => H, fn8: (arg: H) => I): I;
declare function pipe<A, B, C, D, E, F, G, H, I, J>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G, fn7: (arg: G) => H, fn8: (arg: H) => I, fn9: (arg: I) => J): J;
declare function pipe<A, B, C, D, E, F, G, H, I, J, K>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G, fn7: (arg: G) => H, fn8: (arg: H) => I, fn9: (arg: I) => J, fn10: (arg: J) => K): K;
declare function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G, fn7: (arg: G) => H, fn8: (arg: H) => I, fn9: (arg: I) => J, fn10: (arg: J) => K, fn11: (arg: K) => L): L;
declare function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(value: A, fn1: (arg: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G, fn7: (arg: G) => H, fn8: (arg: H) => I, fn9: (arg: I) => J, fn10: (arg: J) => K, fn11: (arg: K) => L, fn12: (arg: L) => M): M;
/**
 * Performs left-to-right function composition and returns a new function, the first argument may have any arity, the remaining arguments must be unary.
 */
declare function flow<A extends any[], B>(fn1: (...args: A) => B): (...args: A) => B;
declare function flow<A extends any[], B, C>(fn1: (...args: A) => B, fn2: (arg: B) => C): (...args: A) => C;
declare function flow<A extends any[], B, C, D>(fn1: (...args: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D): (...args: A) => D;
declare function flow<A extends any[], B, C, D, E>(fn1: (...args: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E): (...args: A) => E;
declare function flow<A extends any[], B, C, D, E, F>(fn1: (...args: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F): (...args: A) => F;
declare function flow<A extends any[], B, C, D, E, F, G>(fn1: (...args: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G): (...args: A) => G;
declare function flow<A extends any[], B, C, D, E, F, G, H>(fn1: (...args: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G, fn7: (arg: G) => H): (...args: A) => H;
declare function flow<A extends any[], B, C, D, E, F, G, H, I>(fn1: (...args: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G, fn7: (arg: G) => H, fn8: (arg: H) => I): (...args: A) => I;
declare function flow<A extends any[], B, C, D, E, F, G, H, I, J>(fn1: (...args: A) => B, fn2: (arg: B) => C, fn3: (arg: C) => D, fn4: (arg: D) => E, fn5: (arg: E) => F, fn6: (arg: F) => G, fn7: (arg: G) => H, fn8: (arg: H) => I, fn9: (arg: I) => J): (...args: A) => J;
/**
 * Invokes the given function with the given value, and then returns the same value.
 */
declare function tap<T>(fn: (value: T) => void): (value: T) => T;
/**
 * Useful for logging values in a pipeline
 */
declare const log: <T>(label: string, fn?: ((a: T) => any) | undefined) => (v: T) => T;
/**
 * Casts a value to a specific type
 */
declare const cast: <T>(v: any) => T;
/**
 * Empty, no-op function
 */
declare const noop: () => undefined;
/**
 * Identity function
 */
declare const identity: <T>(v: T) => T;
/**
 * Returns a function with memoized results
 */
declare const memo: <T extends (...args: any[]) => any>(fn: T) => T;
/**
 * Run a execution in a try/catch block, and return the result of the function or the result of the onError function
 */
declare const tryCatch: <T, U, K>(fn: (v: T) => U, onError?: ((err: unknown, v: T) => K) | undefined) => (v: T) => U | (K extends void ? undefined : K);

export { cast, flow, identity, log, memo, noop, pipe, tap, tryCatch };
