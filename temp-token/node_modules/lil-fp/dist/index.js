"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 == "object" || typeof from2 == "function")
    for (let key of __getOwnPropNames(from2))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Arr: () => arr_exports,
  Bool: () => bool_exports,
  Obj: () => obj_exports,
  Opt: () => opt_exports,
  cast: () => cast,
  flow: () => flow,
  identity: () => identity,
  isArr: () => isArr,
  isBool: () => isBool,
  isFunc: () => isFunc,
  isNum: () => isNum,
  isObj: () => isObj,
  isStr: () => isStr,
  log: () => log,
  match: () => match,
  memo: () => memo,
  noop: () => noop,
  orElse: () => orElse,
  otherwise: () => otherwise,
  pipe: () => pipe,
  tap: () => tap,
  tryCatch: () => tryCatch,
  when: () => when
});
module.exports = __toCommonJS(src_exports);

// src/arr.ts
var arr_exports = {};
__export(arr_exports, {
  at: () => at,
  compact: () => compact,
  concat: () => concat,
  every: () => every,
  filter: () => filter,
  filterMap: () => filterMap,
  flat: () => flat,
  forEach: () => forEach,
  from: () => from,
  has: () => has,
  head: () => head,
  map: () => map,
  next: () => next,
  prev: () => prev,
  reduce: () => reduce,
  some: () => some,
  tail: () => tail,
  uniq: () => uniq
});
var from = (v) => Array.from(v), filter = (f) => (arr) => arr.filter(f), map = (f) => (arr) => arr.map(f), reduce = (f, init) => (arr) => arr.reduce(f, init), filterMap = (f) => (arr) => arr.reduce((acc, v, index, arr2) => {
  let x = f(v, index, arr2);
  return x == null ? acc : [...acc, x];
}, []), forEach = (f) => (arr) => arr.forEach(f), next = (i, loop) => (arr) => arr[(i + 1) % (loop ? arr.length : arr.length - 1)], prev = (i, loop) => (arr) => arr[(i - 1 + (loop ? arr.length : 0)) % arr.length], head = (arr) => arr[0], tail = (arr) => arr[arr.length - 1], at = (i) => (arr) => arr.at(i), uniq = (arr) => [...new Set(arr)], some = (f) => (arr) => arr.some(f), every = (f) => (arr) => arr.every(f), has = (v) => (arr) => arr.includes(v), concat = (...others) => (v) => v.concat(...others), compact = (arr) => arr.filter((v) => v != null), flat = () => (arr) => arr.flat();

// src/bool.ts
var bool_exports = {};
__export(bool_exports, {
  and: () => and,
  not: () => not,
  or: () => or
});
function or(...fns) {
  return (v) => fns.some((fn) => fn(v));
}
var not = (predicate) => (arg) => !predicate(arg);
function and(...predicates) {
  return (arg) => predicates.every((predicate) => predicate(arg));
}

// src/func.ts
function pipe(input, ...functions) {
  return functions.reduce((acc, fn) => fn(acc), input);
}
function flow(...functions) {
  return (input) => functions.reduce((acc, fn) => fn(acc), input);
}
function tap(fn) {
  return (value) => (fn(value), value);
}
var log = (label, fn) => (v) => (console.log(`${label}: `, fn?.(v) ?? v), v), cast = (v) => v, noop = () => {
}, identity = (v) => v, memo = (fn) => {
  let cache = /* @__PURE__ */ Object.create(null);
  return (arg) => (cache[arg] === void 0 && (cache[arg] = fn(arg)), cache[arg]);
}, tryCatch = (fn, onError) => (v) => {
  try {
    return fn(v);
  } catch (err) {
    return cast(onError?.(err, v));
  }
};

// src/is.ts
var isBool = (x) => typeof x == "boolean", isNum = (x) => typeof x == "number", isStr = (x) => typeof x == "string", isArr = (x) => Array.isArray(x), isObj = (x) => x !== null && typeof x == "object" && !isArr(x), isFunc = (x) => typeof x == "function";

// src/logic.ts
var match = (...fns) => (v) => {
  for (let fn of fns) {
    let x = fn(v);
    if (x != null)
      return x;
  }
};
function when(predicate, fn) {
  return (v) => {
    if (predicate(v))
      return fn(v);
  };
}
var otherwise = (fn) => (v) => when(() => !0, fn)(v), orElse = (u) => (v) => (
  // @ts-ignore
  v ?? (typeof u == "function" ? u() : u)
);

// src/obj.ts
var obj_exports = {};
__export(obj_exports, {
  assign: () => assign,
  assignTo: () => assignTo,
  bind: () => bind,
  compact: () => compact2,
  defaults: () => defaults,
  entries: () => entries,
  filter: () => filter2,
  fromEntries: () => fromEntries,
  get: () => get,
  keys: () => keys,
  map: () => map2,
  merge: () => merge,
  omit: () => omit,
  pick: () => pick,
  split: () => split
});
var fromEntries = (entries2) => Object.fromEntries(entries2), map2 = (f) => (obj) => fromEntries(Object.entries(obj).map(([k, v]) => f(k, v))), entries = (obj) => Object.entries(obj);
function assign(v) {
  return (obj) => ({
    ...obj,
    ...isFunc(v) ? v(obj) : v
  });
}
var assignTo = (key) => (prev2) => fromEntries([[key, prev2]]), bind = (key, fn) => (obj) => cast({
  ...obj,
  [key]: fn(obj)
}), keys = (obj) => Object.keys(obj), filter2 = (f) => (obj) => fromEntries(Object.entries(obj).filter(([k, v]) => f(k, v))), compact2 = (obj) => filter2((_, v) => v != null)(obj), split = (...keys2) => (obj) => {
  let descriptors = Object.getOwnPropertyDescriptors(obj), dKeys = Object.keys(descriptors), split2 = (k) => {
    let clone = {};
    for (let i = 0; i < k.length; i++) {
      let key = k[i];
      descriptors[key] && (Object.defineProperty(clone, key, descriptors[key]), delete descriptors[key]);
    }
    return clone;
  }, fn = (key) => split2(Array.isArray(key) ? key : dKeys.filter(key));
  return keys2.map(fn).concat(split2(dKeys));
};
function merge(...args) {
  return (obj) => {
    if (!args.length)
      return obj;
    for (let i = 1; i < args.length; i++) {
      let source = { ...args[i] };
      for (let key in source) {
        let targValue = obj[key], srcValue = source[key];
        isObj(targValue) && isObj(srcValue) ? obj[key] = merge(srcValue)(targValue) : obj[key] = srcValue;
      }
    }
    return obj;
  };
}
var omit = (keys2) => (obj) => {
  let clone = { ...obj };
  for (let i = 0; i < keys2.length; i++)
    delete clone[keys2[i]];
  return clone;
}, pick = (keys2) => (obj) => {
  let clone = {};
  for (let i = 0; i < keys2.length; i++)
    clone[keys2[i]] = obj[keys2[i]];
  return clone;
}, defaults = (defaults2) => (obj) => cast({
  ...defaults2,
  ...obj
}), isSafeKey = (key) => key !== "__proto__" && key !== "prototype" && key !== "constructor", get = (path, undef) => (obj) => {
  let keys2 = Array.isArray(path) ? path : path.split(".");
  for (let i = 0; i < keys2.length; i++) {
    let key = keys2[i];
    if (!obj || !Object.prototype.hasOwnProperty.call(obj, key) || !isSafeKey(key)) {
      obj = void 0;
      break;
    }
    obj = obj[key];
  }
  return cast(obj ?? undef);
};

// src/opt.ts
var opt_exports = {};
__export(opt_exports, {
  filter: () => filter3,
  flatMap: () => flatMap,
  fromExecution: () => fromExecution,
  fromNullable: () => fromNullable,
  fromPredicate: () => fromPredicate,
  getOrElse: () => getOrElse,
  getOrThrow: () => getOrThrow,
  isNone: () => isNone,
  isSome: () => isSome,
  map: () => map3,
  match: () => match2,
  none: () => none,
  orElse: () => orElse2,
  some: () => some2,
  tap: () => tap2
});
var none = Object.freeze({ _tag: "None" }), some2 = (value) => Object.freeze({ _tag: "Some", value });
function fromPredicate(predicate) {
  return (v) => predicate(v) ? some2(v) : none;
}
var fromNullable = (value) => value == null ? none : some2(value), fromExecution = (value) => {
  try {
    return fromNullable(value());
  } catch {
    return none;
  }
}, isNone = (o) => o._tag === "None", isSome = (o) => o._tag === "Some", isOption = (o) => o._tag === "None" || o._tag === "Some", map3 = (f) => (o) => isNone(o) ? none : some2(f(o.value)), flatMap = (f) => (o) => isNone(o) ? none : f(o.value), getOrElse = (def) => (o) => isNone(o) ? def() : o.value, getOrThrow = (msg) => (o) => {
  if (isNone(o))
    throw new Error(msg);
  return o.value;
}, match2 = (onSome, onNone) => (o) => isNone(o) ? onNone() : onSome(o.value), orElse2 = (v) => (o) => {
  let vv = v();
  return isOption(vv) ? isNone(o) ? vv : o : isNone(o) ? some2(vv) : o;
}, tap2 = (f) => (o) => (isSome(o) && f(o.value), o), filter3 = (f) => (o) => isNone(o) ? none : f(o.value) ? o : none;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Arr,
  Bool,
  Obj,
  Opt,
  cast,
  flow,
  identity,
  isArr,
  isBool,
  isFunc,
  isNum,
  isObj,
  isStr,
  log,
  match,
  memo,
  noop,
  orElse,
  otherwise,
  pipe,
  tap,
  tryCatch,
  when
});
