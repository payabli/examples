type Dict = Record<string, any>;
type Compact<T extends Dict> = {
    [K in keyof T]: T[K] extends undefined ? never : T[K];
} & {};
type SplitProp<T> = ReadonlyArray<keyof T>;
type Split<T, K extends SplitProp<T>[]> = [
    ...{
        [P in keyof K]: P extends `${number}` ? Pick<T, Extract<K[P], ReadonlyArray<keyof T>>[number]> : never;
    },
    Omit<T, K[number][number]>
];
type PromiseFactory<T = unknown> = () => PromiseLike<T>;
type Awaited<T> = T extends undefined ? T : T extends PromiseLike<infer U> ? U : T;
type Defaults<T extends Dict, K extends Partial<T>> = Simplify<Omit<T, keyof K> & Required<K>>;
interface Bind {
    <T extends Dict, K extends string, U>(key: K, fn: (value: T) => U): (obj: T) => Assign<[T, Record<K, U>]>;
}
type Simplify<T> = T extends any ? {
    [K in keyof T]: T[K];
} : T;
type Merge<P1 = {}, P2 = {}> = Omit<P1, keyof P2> & P2;
type Assign<T extends unknown[], Target = {}> = T extends [
    infer Next,
    ...infer Rest
] ? Simplify<Assign<Rest, Merge<Target, Next>>> : T extends [...infer Rest, infer Next] ? Simplify<Merge<Assign<Rest, Target>, Next>> : T extends [] ? Simplify<Target> : T extends (infer I)[] ? Simplify<Merge<Target, I>> : Simplify<Target>;
type Primitive = null | undefined | string | number | boolean | symbol | bigint;
type ArrayKey = number;
type IsTuple<T extends readonly any[]> = number extends T['length'] ? false : true;
type TupleKeys<T extends readonly any[]> = Exclude<keyof T, keyof any[]>;
type PathConcat<TKey extends string | number, TValue> = TValue extends Primitive ? `${TKey}` : `${TKey}` | `${TKey}.${Path<TValue>}`;
type Path<T> = T extends readonly (infer V)[] ? IsTuple<T> extends true ? {
    [K in TupleKeys<T>]-?: PathConcat<K & string, T[K]>;
}[TupleKeys<T>] : PathConcat<ArrayKey, V> : {
    [K in keyof T]-?: PathConcat<K & string, T[K]>;
}[keyof T];
type ArrayPathConcat<TKey extends string | number, TValue> = TValue extends Primitive ? never : TValue extends readonly (infer U)[] ? U extends Primitive ? never : `${TKey}` | `${TKey}.${ArrayPath<TValue>}` : `${TKey}.${ArrayPath<TValue>}`;
type ArrayPath<T> = T extends readonly (infer V)[] ? IsTuple<T> extends true ? {
    [K in TupleKeys<T>]-?: ArrayPathConcat<K & string, T[K]>;
}[TupleKeys<T>] : ArrayPathConcat<ArrayKey, V> : {
    [K in keyof T]-?: ArrayPathConcat<K & string, T[K]>;
}[keyof T];
type PathValue<T, TPath extends Path<T> | ArrayPath<T>> = T extends any ? TPath extends `${infer K}.${infer R}` ? K extends keyof T ? R extends Path<T[K]> ? PathValue<T[K], R> : never : K extends `${ArrayKey}` ? T extends readonly (infer V)[] ? PathValue<V, R & Path<V>> : never : never : TPath extends keyof T ? T[TPath] : TPath extends `${ArrayKey}` ? T extends readonly (infer V)[] ? V : never : never : never;

export { ArrayPath, Assign, Awaited, Bind, Compact, Defaults, Dict, Path, PathConcat, PathValue, Primitive, PromiseFactory, Simplify, Split, SplitProp };
