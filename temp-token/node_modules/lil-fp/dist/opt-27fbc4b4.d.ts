/**
 * An Option represents a value that may or may not be present.
 */
type Option<T> = None | Some<T>;
type None = {
    _tag: 'None';
};
type Some<T> = {
    _tag: 'Some';
    value: T;
};
/**
 * The None value represents the absence of a value.
 */
declare const none: Option<never>;
/**
 * The Some value represents the presence of a value.
 */
declare const some: <T>(value: T) => Option<T>;
/**
 * Creates an Option from a predicate function.
 * If the predicate returns true, the value is wrapped in a Some, otherwise None is returned.
 */
declare function fromPredicate<T, U extends T>(predicate: (v: T) => v is U): (v: T) => Option<U>;
/**
 * Creates an Option from a nullable value.
 * If the value is null or undefined, None is returned, otherwise the value is wrapped in a Some.
 */
declare const fromNullable: <T>(value: T | null | undefined) => Option<T>;
/**
 * Creates an Option from a function that may throw an error.
 * If the function throws an error, None is returned, otherwise the result is wrapped in a Some.
 */
declare const fromExecution: <T>(value: () => T | null | undefined) => Option<T>;
/**
 * Whether the given value is a None
 */
declare const isNone: <T>(o: Option<T>) => o is None;
/**
 * Whether the given value is a Some
 */
declare const isSome: <T>(o: Option<T>) => o is Some<T>;
/**
 * Calls the specified callback function on the value of an option if is a Some.
 */
declare const map: <T, U>(f: (value: T) => U) => (o: Option<T>) => Option<U>;
/**
 * Calls the specified callback function on the value of an option if is a Some.
 * It also flattens any nested options.
 */
declare const flatMap: <T, U>(f: (value: T) => Option<U>) => (o: Option<T>) => Option<U>;
/**
 * Returns the value of an option if is a Some, otherwise returns the specified default value.
 */
declare const getOrElse: <T>(def: () => T) => (o: Option<T>) => T;
/**
 * Returns the value of an option if is a Some(value), otherwise it throws an error.
 */
declare const getOrThrow: <T>(msg: string) => (o: Option<T>) => T;
/**
 * Returns the result of someFn if option is Some, otherwise, returns the result of noneFn.
 */
declare const match: <T, U>(onSome: (v: T) => U, onNone: () => U) => (o: Option<T>) => U;
/**
 * Returns the value of an option if is a Some, otherwise returns the result of the alternative function.
 */
declare const orElse: <T>(v: () => T | Option<T>) => (o: Option<T>) => Option<T>;
/**
 * Calls the specified callback function on the value of an option if is a Some.
 * Returns the original option.
 */
declare const tap: <T>(f: (v: T) => void) => (o: Option<T>) => Option<T>;
/**
 * Returns a None if the option is a Some and the value does not satisfy the predicate.
 */
declare const filter: <T>(f: (v: T) => boolean) => (o: Option<T>) => Option<T>;

declare const opt_filter: typeof filter;
declare const opt_flatMap: typeof flatMap;
declare const opt_fromExecution: typeof fromExecution;
declare const opt_fromNullable: typeof fromNullable;
declare const opt_fromPredicate: typeof fromPredicate;
declare const opt_getOrElse: typeof getOrElse;
declare const opt_getOrThrow: typeof getOrThrow;
declare const opt_isNone: typeof isNone;
declare const opt_isSome: typeof isSome;
declare const opt_map: typeof map;
declare const opt_match: typeof match;
declare const opt_none: typeof none;
declare const opt_orElse: typeof orElse;
declare const opt_some: typeof some;
declare const opt_tap: typeof tap;
declare namespace opt {
  export {
    opt_filter as filter,
    opt_flatMap as flatMap,
    opt_fromExecution as fromExecution,
    opt_fromNullable as fromNullable,
    opt_fromPredicate as fromPredicate,
    opt_getOrElse as getOrElse,
    opt_getOrThrow as getOrThrow,
    opt_isNone as isNone,
    opt_isSome as isSome,
    opt_map as map,
    opt_match as match,
    opt_none as none,
    opt_orElse as orElse,
    opt_some as some,
    opt_tap as tap,
  };
}

export { fromNullable as a, fromExecution as b, isSome as c, flatMap as d, getOrThrow as e, fromPredicate as f, getOrElse as g, match as h, isNone as i, orElse as j, filter as k, map as m, none as n, opt as o, some as s, tap as t };
