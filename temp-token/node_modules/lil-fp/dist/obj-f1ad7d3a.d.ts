import { Dict, Assign, Bind, SplitProp, Simplify, Defaults, Path } from './types.js';

/**
 * Returns an object created by key-value entries for properties and methods
 */
declare const fromEntries: <T extends Dict>(entries: IterableIterator<[string, T[keyof T]]> | Iterable<[string, T[keyof T]]>) => T;
/**
 * Returns a new object with the key-value pairs from the original object, but the keys transformed by the given function.
 */
declare const map: <T extends Dict>(f: (key: string, value: T[keyof T]) => [string, T[keyof T]]) => (obj: T) => T;
/**
 * Returns the entries of an object as an array of key-value pairs
 */
declare const entries: <T extends Dict>(obj: T) => [keyof T, T[keyof T]][];
/**
 * Assign object properties to an existing object in a pipeline
 */
declare function assign<T extends Dict, K extends Dict>(v: K | ((obj: T) => K)): (obj: T) => Assign<[T, K]>;
/**
 * Assigns a value in a pipeline to a key in an object
 */
declare const assignTo: <K extends string, T extends Dict>(key: K) => (prev: T) => Record<K, T>;
/**
 * Returns a new object that specified key whose value is the result of calling the provided function
 */
declare const bind: Bind;
/**
 * Returns the keys of an object
 */
declare const keys: <T extends Dict>(obj: T) => (keyof T)[];
/**
 * Filters an object entries by a predicate function
 */
declare const filter: <T extends Dict>(f: (key: keyof T, value: T[keyof T]) => boolean) => (obj: T) => T;
/**
 * Returns a new object with nullish values removed
 */
declare const compact: <T extends Dict>(obj: T) => { [K in keyof T]: T[K] extends undefined ? never : T[K]; };
/**
 * Split an object into multiple objects based on a predicate function
 */
declare const split: <T extends Dict, K extends [SplitProp<T>, ...SplitProp<T>[]]>(...keys: K) => (obj: T) => [...{ [P in keyof K]: P extends `${number}` ? Pick<T, Extract<K[P], readonly (keyof T)[]>[number]> : never; }, Omit<T, K[number][number]>];
/**
 * Merge multiple objects to an object in a pipeline
 */
declare function merge<T, U>(source: U): (target: T) => Assign<[T, U]>;
declare function merge<T, U, V>(target: T): (source: U, source2: V) => Assign<[T, U, V]>;
declare function merge<T, U, V, W>(target: T): (source: U, source2: V, source3: W) => Assign<[T, U, V, W]>;
declare function merge<T, U, V, W, X>(target: T): (source: U, source2: V, source3: W, source4: X) => Assign<[T, U, V, W, X]>;
/**
 * Omit properties from an object in a pipeline
 */
declare const omit: <T extends Dict, K extends keyof T>(keys: K[]) => (obj: T) => Simplify<Omit<T, K>>;
/**
 * Pick properties from an object in a pipeline
 */
declare const pick: <T extends Dict, K extends keyof T>(keys: K[]) => (obj: T) => Simplify<Pick<T, K>>;
/**
 * Assign default values to an object in a pipeline
 */
declare const defaults: <T extends Dict, K extends Partial<T>>(defaults: K) => (obj: T) => Defaults<T, K>;
/**
 * Get a property from an object by dot notation
 */
declare const get: <T extends Dict, K extends Path<T>>(path: K, undef?: T[K] | undefined) => (obj: T) => T[K];

declare const obj_assign: typeof assign;
declare const obj_assignTo: typeof assignTo;
declare const obj_bind: typeof bind;
declare const obj_compact: typeof compact;
declare const obj_defaults: typeof defaults;
declare const obj_entries: typeof entries;
declare const obj_filter: typeof filter;
declare const obj_fromEntries: typeof fromEntries;
declare const obj_get: typeof get;
declare const obj_keys: typeof keys;
declare const obj_map: typeof map;
declare const obj_merge: typeof merge;
declare const obj_omit: typeof omit;
declare const obj_pick: typeof pick;
declare const obj_split: typeof split;
declare namespace obj {
  export {
    obj_assign as assign,
    obj_assignTo as assignTo,
    obj_bind as bind,
    obj_compact as compact,
    obj_defaults as defaults,
    obj_entries as entries,
    obj_filter as filter,
    obj_fromEntries as fromEntries,
    obj_get as get,
    obj_keys as keys,
    obj_map as map,
    obj_merge as merge,
    obj_omit as omit,
    obj_pick as pick,
    obj_split as split,
  };
}

export { assign as a, assignTo as b, bind as c, filter as d, entries as e, fromEntries as f, compact as g, merge as h, omit as i, defaults as j, keys as k, get as l, map as m, obj as o, pick as p, split as s };
