// src/radio-group.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("radio-group").parts(
  "root",
  "label",
  "radio",
  "radioLabel",
  "radioControl",
  "indicator"
);
var parts = anatomy.build();

// src/radio-group.connect.ts
import { dataAttr } from "@zag-js/dom-query";
import { visuallyHiddenStyle } from "@zag-js/visually-hidden";

// src/radio-group.dom.ts
import { createScope, queryAll } from "@zag-js/dom-query";
var dom = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `radio-group:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `radio-group:${ctx.id}:label`,
  getRadioId: (ctx, value) => ctx.ids?.radio?.(value) ?? `radio-group:${ctx.id}:radio:${value}`,
  getRadioHiddenInputId: (ctx, value) => ctx.ids?.radioHiddenInput?.(value) ?? `radio-group:${ctx.id}:radio:input:${value}`,
  getRadioControlId: (ctx, value) => ctx.ids?.radioControl?.(value) ?? `radio-group:${ctx.id}:radio:control:${value}`,
  getRadioLabelId: (ctx, value) => ctx.ids?.radioLabel?.(value) ?? `radio-group:${ctx.id}:radio:label:${value}`,
  getIndicatorId: (ctx) => ctx.ids?.indicator ?? `radio-group:${ctx.id}:indicator`,
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getRadioHiddenInputEl: (ctx, value) => dom.getById(ctx, dom.getRadioHiddenInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom.getById(ctx, dom.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => dom.getRootEl(ctx)?.querySelector("input:not(:disabled)"),
  getFirstEnabledAndCheckedInputEl: (ctx) => dom.getRootEl(ctx)?.querySelector("input:not(:disabled):checked"),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value)
      return;
    return dom.getById(ctx, dom.getRadioId(ctx, ctx.value));
  },
  getOffsetRect: (el) => ({
    left: el?.offsetLeft ?? 0,
    top: el?.offsetTop ?? 0,
    width: el?.offsetWidth ?? 0,
    height: el?.offsetHeight ?? 0
  }),
  getRectById: (ctx, id) => {
    const radioEl = dom.getById(ctx, dom.getRadioId(ctx, id));
    if (!radioEl)
      return;
    return dom.resolveRect(dom.getOffsetRect(radioEl));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});

// src/radio-group.connect.ts
function connect(state, send, normalize) {
  const isGroupDisabled = state.context.isDisabled;
  function getRadioState(props) {
    const radioState = {
      isInvalid: !!props.invalid,
      isDisabled: !!props.disabled || isGroupDisabled,
      isChecked: state.context.value === props.value,
      isFocused: state.context.focusedId === props.value,
      isHovered: state.context.hoveredId === props.value,
      isActive: state.context.activeId === props.value
    };
    return {
      ...radioState,
      isInteractive: !radioState.isDisabled
    };
  }
  function getRadioDataAttrs(props) {
    const radioState = getRadioState(props);
    return {
      "data-focus": dataAttr(radioState.isFocused),
      "data-disabled": dataAttr(radioState.isDisabled),
      "data-state": radioState.isChecked ? "checked" : "unchecked",
      "data-hover": dataAttr(radioState.isHovered),
      "data-invalid": dataAttr(radioState.isInvalid),
      "data-orientation": state.context.orientation
    };
  }
  const focus = () => {
    const firstEnabledAndCheckedInput = dom.getFirstEnabledAndCheckedInputEl(state.context);
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    const firstEnabledInput = dom.getFirstEnabledInputEl(state.context);
    firstEnabledInput?.focus();
  };
  return {
    value: state.context.value,
    setValue(value) {
      send({ type: "SET_VALUE", value, isTrusted: false });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, isTrusted: false });
    },
    focus,
    getRadioState,
    rootProps: normalize.element({
      ...parts.root.attrs,
      role: "radiogroup",
      id: dom.getRootId(state.context),
      "aria-labelledby": dom.getLabelId(state.context),
      "data-orientation": state.context.orientation,
      "data-disabled": dataAttr(isGroupDisabled),
      "aria-orientation": state.context.orientation,
      dir: state.context.dir
    }),
    labelProps: normalize.element({
      ...parts.label.attrs,
      "data-orientation": state.context.orientation,
      "data-disabled": dataAttr(isGroupDisabled),
      id: dom.getLabelId(state.context),
      onClick: focus
    }),
    getRadioProps(props) {
      const rootState = getRadioState(props);
      return normalize.label({
        ...parts.radio.attrs,
        id: dom.getRadioId(state.context, props.value),
        htmlFor: dom.getRadioHiddenInputId(state.context, props.value),
        ...getRadioDataAttrs(props),
        onPointerMove() {
          if (!rootState.isInteractive)
            return;
          send({ type: "SET_HOVERED", value: props.value, hovered: true });
        },
        onPointerLeave() {
          if (!rootState.isInteractive)
            return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (!rootState.isInteractive)
            return;
          if (rootState.isFocused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props.value, active: true });
        },
        onPointerUp() {
          if (!rootState.isInteractive)
            return;
          send({ type: "SET_ACTIVE", value: null });
        }
      });
    },
    getRadioLabelProps(props) {
      return normalize.element({
        ...parts.radioLabel.attrs,
        id: dom.getRadioLabelId(state.context, props.value),
        ...getRadioDataAttrs(props)
      });
    },
    getRadioControlProps(props) {
      const controlState = getRadioState(props);
      return normalize.element({
        ...parts.radioControl.attrs,
        id: dom.getRadioControlId(state.context, props.value),
        "data-active": dataAttr(controlState.isActive),
        "aria-hidden": true,
        ...getRadioDataAttrs(props)
      });
    },
    getRadioHiddenInputProps(props) {
      const inputState = getRadioState(props);
      return normalize.input({
        "data-ownedby": dom.getRootId(state.context),
        id: dom.getRadioHiddenInputId(state.context, props.value),
        type: "radio",
        name: state.context.name || state.context.id,
        form: state.context.form,
        value: props.value,
        onChange(event) {
          if (inputState.isDisabled)
            return;
          if (event.target.checked) {
            send({ type: "SET_VALUE", value: props.value, isTrusted: true });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null });
        },
        onFocus() {
          send({ type: "SET_FOCUSED", value: props.value, focused: true });
        },
        onKeyDown(event) {
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: inputState.isDisabled,
        defaultChecked: inputState.isChecked,
        style: visuallyHiddenStyle
      });
    },
    indicatorProps: normalize.element({
      id: dom.getIndicatorId(state.context),
      ...parts.indicator.attrs,
      "data-disabled": dataAttr(isGroupDisabled),
      "data-orientation": state.context.orientation,
      style: {
        "--transition-duration": "150ms",
        "--transition-property": "left, top, width, height",
        position: "absolute",
        willChange: "var(--transition-property)",
        transitionProperty: "var(--transition-property)",
        transitionDuration: state.context.canIndicatorTransition ? "var(--transition-duration)" : "0ms",
        transitionTimingFunction: "var(--transition-timing-function)",
        ...state.context.indicatorRect
      }
    })
  };
}

// src/radio-group.machine.ts
import { createMachine, guards } from "@zag-js/core";
import { nextTick } from "@zag-js/dom-query";
import { trackElementRect } from "@zag-js/element-rect";
import { dispatchInputCheckedEvent, trackFormControl } from "@zag-js/form-utils";
import { compact, isEqual, isString } from "@zag-js/utils";
var { not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "radio",
      initial: "idle",
      context: {
        value: null,
        activeId: null,
        focusedId: null,
        hoveredId: null,
        disabled: false,
        ...ctx,
        indicatorRect: {},
        canIndicatorTransition: false,
        fieldsetDisabled: false
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      entry: ["syncIndicatorRect"],
      exit: ["cleanupObserver"],
      activities: ["trackFormControlState"],
      watch: {
        value: ["setIndicatorTransition", "syncIndicatorRect", "syncInputElements"]
      },
      on: {
        SET_VALUE: [
          {
            guard: not("isTrusted"),
            actions: ["setValue", "dispatchChangeEvent"]
          },
          {
            actions: ["setValue"]
          }
        ],
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value });
            }
          });
        }
      },
      actions: {
        setValue(ctx2, evt) {
          set.value(ctx2, evt.value);
        },
        setHovered(ctx2, evt) {
          ctx2.hoveredId = evt.value;
        },
        setActive(ctx2, evt) {
          ctx2.activeId = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focusedId = evt.value;
        },
        syncInputElements(ctx2) {
          const inputs = dom.getInputEls(ctx2);
          inputs.forEach((input) => {
            input.checked = input.value === ctx2.value;
          });
        },
        setIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = isString(ctx2.value);
        },
        cleanupObserver(ctx2) {
          ctx2.indicatorCleanup?.();
        },
        syncIndicatorRect(ctx2) {
          ctx2.indicatorCleanup?.();
          if (!dom.getIndicatorEl(ctx2))
            return;
          const value = ctx2.value;
          if (value == null) {
            ctx2.indicatorRect = {};
            return;
          }
          const radioEl = dom.getActiveRadioEl(ctx2);
          if (!radioEl)
            return;
          ctx2.indicatorCleanup = trackElementRect(radioEl, {
            getRect(el) {
              return dom.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom.resolveRect(rect);
              nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        },
        dispatchChangeEvent(ctx2) {
          const inputEls = dom.getInputEls(ctx2);
          inputEls.forEach((inputEl) => {
            const checked = inputEl.value === ctx2.value;
            if (checked === inputEl.checked)
              return;
            dispatchInputCheckedEvent(inputEl, { checked });
          });
        }
      }
    }
  );
}
var invoke = {
  change: (ctx) => {
    if (ctx.value == null)
      return;
    ctx.onValueChange?.({ value: ctx.value });
  }
};
var set = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke.change(ctx);
  }
};
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map