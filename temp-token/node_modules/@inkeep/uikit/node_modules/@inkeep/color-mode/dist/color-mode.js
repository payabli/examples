"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/color-mode.ts
var color_mode_exports = {};
__export(color_mode_exports, {
  ColorModeProvider: () => ColorModeProvider,
  DarkModeProvider: () => DarkModeProvider,
  useColorMode: () => useColorMode,
  useColorModeValue: () => useColorModeValue
});
module.exports = __toCommonJS(color_mode_exports);

// src/color-mode-provider.tsx
var import_react = require("react");
var import_jsx_runtime = require("react/jsx-runtime");
var colorSchemes = ["light", "dark"];
var MEDIA = "(prefers-color-scheme: dark)";
var isServer = typeof window === "undefined";
var ColorModeContext = (0, import_react.createContext)(
  void 0
);
var defaultContext = {
  setColorMode: (_) => {
  },
  colorModes: []
};
var useColorMode = () => (0, import_react.useContext)(ColorModeContext) ?? defaultContext;
function useColorModeValue(light, dark) {
  const props = useColorMode();
  const colorMode = props.forcedColorMode ?? props.resolvedColorMode;
  return colorMode === "dark" ? dark : light;
}
var ColorModeProvider = (props) => {
  const context = (0, import_react.useContext)(ColorModeContext);
  if (context)
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: props.children });
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ColorMode, { ...props });
};
var noop = () => {
};
var forcedDark = {
  setColorMode: noop,
  colorModes: ["dark"],
  colorMode: "dark",
  forcedColorMode: "dark",
  resolvedColorMode: "dark",
  systemColorMode: "dark"
};
var DarkModeProvider = ({
  children
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ColorModeContext.Provider, { value: forcedDark, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { "data-theme": "dark", children }) });
};
var defaultColorModes = ["light", "dark"];
var ColorMode = ({
  forcedColorMode,
  disableTransitionOnChange = false,
  enableSystem = false,
  enableColorScheme = true,
  storageKey = "inkeep-colorMode",
  colorModes = defaultColorModes,
  defaultColorMode = enableSystem ? "system" : "light",
  attribute = "data-theme",
  value,
  children,
  nonce,
  shadowHostId,
  rootId
}) => {
  const [colorMode, setColorModeState] = (0, import_react.useState)(
    () => getColorMode(storageKey, defaultColorMode)
  );
  const [resolvedColorMode, setResolvedColorMode] = (0, import_react.useState)(
    () => getColorMode(storageKey)
  );
  const attrs = !value ? colorModes : Object.values(value);
  const applyColorMode = (0, import_react.useCallback)((colorMode2) => {
    let resolved = colorMode2;
    if (!resolved)
      return;
    if (colorMode2 === "system" && enableSystem) {
      resolved = getSystemColorMode();
    }
    const name = value ? value[resolved] : resolved;
    const enable = disableTransitionOnChange ? disableAnimation() : null;
    const shadowRoot = shadowHostId && rootId && document.getElementById(shadowHostId)?.shadowRoot;
    const d = shadowRoot ? shadowRoot.getElementById(rootId) ?? document.documentElement : document.documentElement;
    if (attribute === "class") {
      d.classList.remove(...attrs);
      if (name)
        d.classList.add(name);
    } else {
      if (name) {
        d.setAttribute(attribute, name);
      } else {
        d.removeAttribute(attribute);
      }
    }
    if (enableColorScheme) {
      const fallback = colorSchemes.includes(defaultColorMode) ? defaultColorMode : null;
      const colorScheme = colorSchemes.includes(resolved) ? resolved : fallback;
      d.style.colorScheme = colorScheme;
    }
    enable?.();
  }, []);
  const setColorMode = (0, import_react.useCallback)(
    (colorMode2) => {
      setColorModeState(colorMode2);
      try {
        localStorage.setItem(storageKey, colorMode2);
      } catch (e) {
      }
    },
    [forcedColorMode]
  );
  const handleMediaQuery = (0, import_react.useCallback)(
    (e) => {
      const resolved = getSystemColorMode(e);
      setResolvedColorMode(resolved);
      if (colorMode === "system" && enableSystem && !forcedColorMode) {
        applyColorMode("system");
      }
    },
    [colorMode, forcedColorMode]
  );
  (0, import_react.useEffect)(() => {
    const media = window.matchMedia(MEDIA);
    media.addListener(handleMediaQuery);
    handleMediaQuery(media);
    return () => media.removeListener(handleMediaQuery);
  }, [handleMediaQuery]);
  (0, import_react.useEffect)(() => {
    const handleStorage = (e) => {
      if (e.key !== storageKey) {
        return;
      }
      const colorMode2 = e.newValue || defaultColorMode;
      setColorMode(colorMode2);
    };
    window.addEventListener("storage", handleStorage);
    return () => window.removeEventListener("storage", handleStorage);
  }, [setColorMode]);
  (0, import_react.useEffect)(() => {
    applyColorMode(forcedColorMode ?? colorMode);
  }, [forcedColorMode, colorMode]);
  const providerValue = (0, import_react.useMemo)(
    () => ({
      colorMode,
      setColorMode,
      forcedColorMode,
      resolvedColorMode: colorMode === "system" ? resolvedColorMode : colorMode,
      colorModes: enableSystem ? [...colorModes, "system"] : colorModes,
      systemColorMode: enableSystem ? resolvedColorMode : void 0
    }),
    [
      colorMode,
      setColorMode,
      forcedColorMode,
      resolvedColorMode,
      enableSystem,
      colorModes
    ]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(ColorModeContext.Provider, { value: providerValue, children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      ColorModeScript,
      {
        ...{
          forcedColorMode,
          disableTransitionOnChange,
          enableSystem,
          enableColorScheme,
          storageKey,
          colorModes,
          defaultColorMode,
          attribute,
          value,
          children,
          attrs,
          nonce,
          shadowHostId,
          rootId
        }
      }
    ),
    children
  ] });
};
var ColorModeScript = (0, import_react.memo)(
  ({
    forcedColorMode,
    storageKey,
    attribute,
    enableSystem,
    enableColorScheme,
    defaultColorMode,
    value,
    attrs,
    nonce,
    shadowHostId,
    rootId
  }) => {
    const defaultSystem = defaultColorMode === "system";
    const optimization = (() => {
      const host = shadowHostId && rootId ? `document.getElementById('${shadowHostId}').shadowRoot.getElementById('${rootId}')` : `document.documentElement`;
      if (attribute === "class") {
        const removeClasses = `c.remove(${attrs.map((t) => `'${t}'`).join(",")})`;
        return `var d=${host},c=d.classList;${removeClasses};`;
      } else {
        return `var d=${host},n='${attribute}',s='setAttribute';`;
      }
    })();
    const fallbackColorScheme = (() => {
      if (!enableColorScheme) {
        return "";
      }
      const fallback = colorSchemes.includes(defaultColorMode) ? defaultColorMode : null;
      if (fallback) {
        return `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${defaultColorMode}'`;
      } else {
        return `if(e==='light'||e==='dark')d.style.colorScheme=e`;
      }
    })();
    const updateDOM = (name, literal = false, setColorScheme = true) => {
      const resolvedName = value ? value[name] : name;
      const val = literal ? name + `|| ''` : `'${resolvedName}'`;
      let text = "";
      if (enableColorScheme && setColorScheme && !literal && colorSchemes.includes(name)) {
        text += `d.style.colorScheme = '${name}';`;
      }
      if (attribute === "class") {
        if (literal || resolvedName) {
          text += `c.add(${val})`;
        } else {
          text += `null`;
        }
      } else {
        if (resolvedName) {
          text += `d[s](n,${val})`;
        }
      }
      return text;
    };
    const scriptSrc = (() => {
      if (forcedColorMode) {
        return `!function(){${optimization}${updateDOM(forcedColorMode)}}()`;
      }
      if (enableSystem) {
        return `!function(){try{${optimization}var e=localStorage.getItem('${storageKey}');if('system'===e||(!e&&${defaultSystem})){var t='${MEDIA}',m=window.matchMedia(t);if(m.media!==t||m.matches){${updateDOM(
          "dark"
        )}}else{${updateDOM("light")}}}else if(e){${value ? `var x=${JSON.stringify(value)};` : ""}${updateDOM(value ? `x[e]` : "e", true)}}${!defaultSystem ? `else{` + updateDOM(defaultColorMode, false, false) + "}" : ""}${fallbackColorScheme}}catch(e){}}()`;
      }
      return `!function(){try{${optimization}var e=localStorage.getItem('${storageKey}');if(e){${value ? `var x=${JSON.stringify(value)};` : ""}${updateDOM(value ? `x[e]` : "e", true)}}else{${updateDOM(
        defaultColorMode,
        false,
        false
      )};}${fallbackColorScheme}}catch(t){}}();`;
    })();
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("script", { nonce, dangerouslySetInnerHTML: { __html: scriptSrc } });
  },
  // Never re-render this component
  () => true
);
var getColorMode = (key, fallback) => {
  if (isServer)
    return void 0;
  let colorMode;
  try {
    colorMode = localStorage.getItem(key) || void 0;
  } catch (e) {
  }
  return colorMode || fallback;
};
var disableAnimation = () => {
  const css = document.createElement("style");
  css.appendChild(
    document.createTextNode(
      `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
    )
  );
  document.head.appendChild(css);
  return () => {
    (() => window.getComputedStyle(document.body))();
    setTimeout(() => {
      document.head.removeChild(css);
    }, 1);
  };
};
var getSystemColorMode = (e) => {
  if (!e)
    e = window.matchMedia(MEDIA);
  const isDark = e.matches;
  const systemColorMode = isDark ? "dark" : "light";
  return systemColorMode;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ColorModeProvider,
  DarkModeProvider,
  useColorMode,
  useColorModeValue
});
